# 操作系统-Linux

## 目录结构

| 目录  |                          功能                           |
| :---: | :-----------------------------------------------------: |
| /bin  |             binaries：存放二进制可执行文件              |
| /sbin | super user binaries：存放二进制可执行文件，仅root可访问 |
| /etc  |               etecetera：存放系统配置文件               |
| /usr  |        unix shared resources：存放共享的系统资源        |
| /home |                   存放用户文件根目录                    |
| /root |                      超级用户目录                       |
| /dev  |                  devices：存放设备文件                  |
| /lib  |      library：存放文件系统中需要的共享库和内核模块      |
| /mnt  |        mount：系统管理员安装临时文件系统的安装点        |
| /boot |               存放用于系统引导使用的文件                |
| /tmp  |                 temporary：存放临时文件                 |
| /var  |         variable：存放运行时需要改变数据的文件          |



## 命令

[参考](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html)

### 常用命令

|      命令      | 功能                      | 补充                                                         |                             示例                             |
| :------------: | :------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------: |
|       cd       | 切换目录                  | /  根目录<br />.  当前目录<br />..  上一级目录<br />~  用户主目录<br />-  上一次操作的的目录 |                                                              |
|       su       | 切换用户                  | - 表示用户的环境变量一起切换<br />-c 表示仅用来执行一次命令，不会切换用户 |                     `su - root -c "pwd"`                     |
|      sudo      | 系统权限                  | 使用 `sudo`命令前缀执行系统管理命令。执行系统管理命令时无需知道超级用户的口令，使用普通用户自己的口令即可。 |                                                              |
|  pwd *[-LP]*   | 显示当前工作目录          | -L  显示链路路径，当前路径（默认）<br />-P  显示物理路径     |                                                              |
|   cat *[-n]*   | 显示文件内容              | -n  显示行号<br />-A  显示所有内容，包括隐藏字符<br />-b  显示行号，不显示空白行行号 |                                                              |
|      more      | 分页显示文件内容          | 分页显示，`space/f`下一页，`b`上一页，`enter`下一行，`v`编辑，`q`退出<br />-num  一次显示行数<br />-s  多行空白缩略为一行空白<br />+num  从第num开始显示 |                                                              |
|      head      | 查看文件前几行            | -n  指定行数（默认10行）                                     |                                                              |
|      tail      | 查看文件后几行            | -n  指定行数<br />-f  动态显示文件内容                       |                                                              |
|       ln       | 创建链接文件              | 为某一个文件在另一个位置建立同步的链接<br />**创建软链接**<br />ln -s [源文件] [目标文件]<br />**创建硬链接**<br /> ln [源文件] [目标文件] |             `ln -s /etc/service ./service.soft`              |
| ls *[-alrRd]*  | 显示文件列表              | -a  显示所有文件，隐藏文件以及特殊目录.与..<br />-l  显示详细信息，ll相当于ls -l<br />-R  递归显示当前目录下所有目录<br />-r  逆序排序<br />-t  按修改时间排序（降序） |                                                              |
|  mkdir *[-p]*  | 创建目录                  | -p  若父级目录不存在则先创建父目录<br />如果不使用该参数会报错 |                                                              |
|   rm *[-rf]*   | 删除文件                  | -i  删除前逐一确认<br />-f  强制删除，不经确认<br />-r  递归删除 |                                                              |
|   cp *[-rp]*   | 复制文件/目录             | -r/R  递归处理（复制目录用）<br />-p  保留文件属性（时间不变）<br />-d  复制保留链接（快捷方式）<br />-a  相当于-dpr <br />-f  覆盖文件不提示<br />-i  覆盖文件前询问<br />-l  不复制，只生成链接文件 |             `cp –R **/**ect/service /root/test`              |
|       mv       | 移动文件                  | 文件重命名<br />文件移动到指定目录<br />目录重命名<br />目录移动到指令目录 |                                                              |
|  tar *[-zvf]*  | 打包/解包                 | -c 创建新tar文件，保留源文件<br />-v 显示运行过程信息<br />-f 指定文件名<br />-z 调用gzip命令压缩、解压<br />-t 查看压缩文件内容<br />-x 解开tar文件<br />-r  追加文件<br />-u  更新文件 | 打包：`tar –cvf xxx.tar ./`<br />打包并压缩：`tar –czvf xxx.tar.gz ./ `<br />解压：<br />`tar –xvf xxx.tar`    <br />`tar -xzvf xxx.tar.gz -C /usr/aaa` |
|      gzip      | 压缩/解压                 | 压缩后缀为.gz，-r压缩目录，不保留原文件<br />-d  解压<br />-l  列出压缩文件信息<br />-N  压缩保存原文件名时间戳<br />-n  压缩不保存原文件名时间戳<br />-r  递归处理指定目录及子目录<br />-v  显示过程 |                                                              |
|      man       | 获取命令/配置文件帮助信息 |                                                              |                           `man ls`                           |
|      find      | 查找文件/目录             | **语法：find [搜索路径] [匹配条件]**<br />-name  按名称精确查找<br />-name  按名称查找忽略大小写<br />-type  按文件类型查找（f文件l软链接d目录）<br />-maxdepth  最大查找深度<br />-size  按文件大小（block为单位，1k=2block，+大于-小于）<br />字符匹配：*所有?单个字符<br />[参考](https://blog.csdn.net/yangxiaoyan12/article/details/86567648) | 在etc目录下找出大于100MB文件<br />`find /etc -size -204800`  |
| grep *[-cinv]* | 查找文件中字符串          | **语法：grep [-cinv] '搜寻字符串' filename**<br />-c  输出匹配行的次数<br />-i  忽略大小写<br />-n  显示匹配行，行号<br />-v  反选，显示不匹配的<br />-r  递归查找 | 查找指定目录/etc/acpi 及其子目录下所有文件中包含字符串"update"的文件，并打印出该字符串所在行的内容：<br />`grep -r update /etc/acpi` |
|    shutdown    |                           | -h  关机<br />-r  重启                                       | `shutdown -h  now`  立即关机<br />`shutdown  -h  20:30`  定时关机 |
|      ping      | 测试网络连通性            | -c  指定发送次数                                             |                    `ping -c 3 127.0.0.1`                     |
| ps *[-auxle]*  | 查看系统进程信息          | -a  显示所有用户进程<br />-u  显示用户名和启动时间<br />-x  显示没有控制终端的进程<br />-e  显示所有进程<br />-l   长格式显示 | `ps -le` 查看系统中所有进程(Linux标准命令格式)<br />`ps aux | grep sam`    查看用户sam执行的进程 |
|     pstree     | 查看进程树                | -p  显示进程pid<br />-u  显示进程所属用户                    |                                                              |
|      kill      | 关闭进程                  | 语法：kill [-选项] PID<br />-9  强制关闭<br />-1  重启进程   |                                                              |
|    useradd     | 添加用户                  | -g  指定用户组（默认同名组）<br />-r   创建系统用户[^7]（非root）<br />-d  指定用户home目录（默认home目录下同名目录）<br />-u  指定用户id<br />-s   指定用户登入后使用的shell<br />-M  不自动创建用户home目录 | `useradd -d /home/myd tt`<br />`useradd caojh -u 544`<br />`useradd nginx -g nginx -s /sbin/nologin -M` |
|     passwd     | 设置用户密码              |                                                              |                        `passwd user1`                        |
|    usermod     | 修改用户配置              | -d  修改用户home目录<br />-g  修改用户组                     |                `usermod –d /users/us1 user1`                 |
|    userdel     | 删除用户                  | -r  同时删除工作目录                                         |                                                              |
|    groupadd    | 添加用户组                |                                                              |                                                              |
|    netstat     | 查看端口和进程情况        | -t  显示tcp相关<br />-u  显示udp相关<br />-n  不显示别名，转化为数字<br />-l  列出监听（Listen）的服务<br />-p  显示相关程序名 |                       `netstat -tunl`                        |
|      kill      | 杀死程序                  | -9  彻底杀死进程<br />-KILL  强制杀死进程                    | `kill -9 26993` 杀死pid为26993的程序<br />`kill -9 $(ps -ef | grep hnlinux)` <br />`kill -u hnlinux`<br />杀死hnlinux用户所有进程 |



> - **cat指令的拓展用法：**配合 `> `将一个文件的内容写入另一个文件
>
>   cat -n file1 > file2：将file1的内容加上行号后输入到file2中（覆盖式）
>
>   cat -n file1 file2 > file3：把file1与file2中内容加上行号后输入file3中
>
>   cat /dev/null > /etc/test.txt：清空 /etc/test.txt 文档内容
>
> - **head/tail拓展用法：**获取一个大文件的部分文件
>
>   head -n 100 /etc/services >config.log
>
> - **软链接/硬链接：**硬链接相当于创建文件副本，软链接相当于快捷方式

[^7]: 系统用户：特定的低权限用户账号，这些用户一般不允许登录到系统，而仅用于维持系统或某个程序的正常运行。分配的uid和gid不大于1000，不会创建主目录。



### 管道

Linux命令重要概念，作用是将一个命令的输出作为另一个命令的输入。

如：

- `ls --help | more `分页查询帮助信息
- `ps –ef | grep java`查询名称中包含java的进程



### VIM编辑器

用于编辑/查看文件

- 切换命令行模式：`esc`
- 切换插入模式：`i`当前位置前插入 `o`当前位置下一行插入 `a`当前位置后插入
- 切换底行模式：`:`
- 编辑文件：`vim` file
- 搜索字符：`/`切换搜索模式 `n`下一个搜索结果 `N`上一个搜索结果
- 退出：`esc`然后输入`:q`



## 快捷常用命令

```powershell
# 查看端口占用情况
netstat -tunlp
# Linux 常用的查看当前系统版本的命令
cat /etc/os-release
# 解压文件
tar -zxvf jdk-8u251-linux-x64.tar.gz
```



## 快捷键



|     功能     |    键位    |
| :----------: | :--------: |
| 停止当前进程 | `ctrl`+`c` |
|     清屏     | `ctrl`+`l` |
|              |            |





## 权限管理



### 格式

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101903936.jpg)

- 第1位：文件类型

- 第2~4位：所有者权限（u）

- 第5~7位：所属组权限（g）

- 第8~10位：其他用户权限（o）

- 第2~10位：所有权限（a=ugo）

  

### 文件类型

- d  目录
- \-   普通文件
- l   链接文件



### 权限分类

| 字符 | 权限 | 文件操作     | 目录操作                      |
| :--: | ---- | ------------ | ----------------------------- |
|  r   | 读   | 查看文件内容 | 可查看目录的文件列表（ls）    |
|  w   | 写   | 修改文件内容 | 可在目录增删文件（mkdir，rm） |
|  x   | 执行 | 可以执行文件 | 可以进入目录（cd）            |

**八进制语法**

| #    | 权限       | rwx  |
| ---- | ---------- | ---- |
| 7    | 读 写 执行 | rwx  |
| 6    | 读 写      | rw-  |
| 5    | 读 执行    | r-x  |
| 4    | 只读       | r--  |
| 3    | 写 执行    | -wx  |
| 2    | 只写       | -w-  |
| 1    | 只执行     | --x  |
| 0    | 无         | ---  |



### 权限更改



#### 改变文件/目录权限

```shell
# chmod [ugoa...][[+-=][rwxX]...][,...] file...
# chmod [mode=421] [ 文件或目录]
chmod ugo+r file1.txt  # 将文件 file1.txt 设为所有人皆可读取 
chmod a+r file1.txt  # 同上
# 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入
chmod ug+w,o-w file1.txt file2.txt  
chmod -R a+r * # 将目前目录下的所有文件与子目录皆设为任何人可读取
chmod 777 file  # 相当于chmod a=rwx file
```

- 参数：-R  递归操作
- 数字表示权限：4=r，2=w，x=1
- +表示增加权限，-表示取消权限，=表示设定唯一权限
- 超级用户root无视权限，普通用户不能修改其他普通用户的权限



#### 更改文件/目录所有者

```shell
# chown user[:group] file...
chown lee file1   # 把file1文件的所有者改为用户lee
chown lee:test file1   # 把file1文件的所有者改为用户lee,所属组改为test
chown –R lee:test dir   # 修改dir及其子目录的所有者和所属组
```

- 参数：-R  递归操作
- 参数格式：
  - user  新所有者
  - group新群组名



#### 更改所属组

```shell
# chgrp [group] file...
chgrp root test.log # 把test.log的所属组修改为root
```



## 用户/用户组管理

### 相关指令

#### 添加账号

```powershell
useradd 
# -d 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录
# -s 指定shell登录目录 即登陆后默认位置
# -g 指定用户主组 -G 指定用户附加组
# 如创建了一个用户sam，主目录 /home/sam  如果目录不存在则创建
useradd -d  /home/sam -m sam
# 如创建一个用户gem 登录目录/bin/sh 主组group 附加组adm和root
useradd -s /bin/sh -g group –G adm,root gem
```

#### 删除账号

```powershell
userdel
# -r 连同用户主目录一起删除
# 如删除sam用户
userdel -r sam
```

#### 修改账号

```powershell
usermod
# 选项同useradd
# -l 修改用户名
# 如修改sam用户的主目录 登录目录 以及用户组
usermod -s /bin/ksh -d /home/z –g developer sam
```

#### 管理用户口令（密码）

```powershell
passwd
# -l 禁用账号,不能登录
# -d 解除密码
# -f 强迫下一次登录修改密码
# -u 口令解锁（密码登录）
# 如 修改sam用户口令
passwd sam
# 指定空密码
passwd -d sam
```

#### 添加用户组

```powershell
groupadd
# -g GID 指定新用户组的组标识号（GID）
# 如向系统中增加了一个新组group2，同时指定新组的组标识号是101。
groupadd -g 101 group2
```

#### 删除用户组

```powershell
groupdel
```

#### 修改用户组

```powershell
groupmod
# -g GID 为用户组指定新的组标识号。
# -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
# -n 新用户组 将用户组的名字改为新名字
# 如将组group2的标识号改为10000，组名修改为group3
groupmod –g 10000 -n group3 group2
```



### 相关文件

#### /etc/passwd

Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。

```powershell
#	对应含义:
#	用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell

root:x:0:0:Superuser:/:
daemon:x:1:1:System daemons:/etc:
bin:x:2:2:Owner of system commands:/bin:
sys:x:3:3:Owner of system files:/usr/sys:
adm:x:4:4:System accounting:/usr/adm:
uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
auth:x:7:21:Authentication administrator:/tcb/files/auth:
cron:x:9:16:Cron daemon:/usr/spool/cron:
listen:x:37:4:Network daemon:/usr/net/nls:
lp:x:71:18:Printer administrator:/usr/spool/lp:
sam:x:200:50:Sam san:/home/sam:/bin/sh
```

#### /etc/group

存储用户组信息

```powershell
# 对应含义:
# 组名:口令:组标识号:组内用户列表

root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam
```



## 上传下载



## 补充



### 修改主机名hostname

```shell
#系统 centos7
hostnamectl   # 查看主机信息
hostnamectl set-name [主机名] #临时修改主机名  重新登录显示新hostname
hostnamectl set-hostname --static  [主机名]  #修改静态主机名 重启不影响
```



### linux 命令终端提示符显示-bash-4.2

**起因**：

登录linux用户终端提示符显示的是-bash-4.2# 而不是root@主机名 + 路径的显示方式

  <img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101903701.png" alt="image-20210205231955093"  />

  **解决方法**：

查询该用户的用户目录 如果没有则创建

 ```shell
cat /etc/passwd
mkdir /home/mysql
#复制/etc/skel这个目录的文件到/home/mysql中
[root@localhost home]$ cp /etc/skel/.bash_logout /home/mysql
[root@localhost home]$ cp /etc/skel/.bash_profile /home/mysql
[root@localhost home]$ cp /etc/skel/.bashrc /home/mysql
 ```

为了防止出现这样的问题，即用户没有对应的用户目录，可以在创建时提供参数

```shell
useradd -d /home/test -m test;
# -m自动创建用户目录，并把框架目录(默认为/etc/skel)下的文件复制到用户主目录下。
# -d设置用户目录
```

当然，出现这个问题也可能是因为创建时设置了-M参数（不自动创建用户目录）



### 修改ssh端口

- 修改/etc/ssh/sshd_config文件

  ```sh
  vim /etc/ssh/sshd_config
  ```

- 找到Port字段，解开注释修改为自定义端口

  ![image-20220521192238179](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220521192238179.png)

- 修改后重启SSH服务

  ```shell
  service sshd restart 
  # 或者
  systemctl restart sshd
  # 或者
  /etc/init.d/sshd restart
  ```

- 别忘了防火墙/安全组放开对应端口





# 容器-Docker

[参考](https://yeasy.gitbook.io/docker_practice/)

## 什么是Docker

**Docker** 使用 `Google` 公司推出的 [Go 语言](https://golang.google.cn) 进行开发实现，基于 `Linux` 内核的 [cgroup](https://zh.wikipedia.org/wiki/Cgroups)，[namespace](https://en.wikipedia.org/wiki/Linux_namespaces)，以及 [OverlayFS](https://docs.docker.com/storage/storagedriver/overlayfs-driver/) 类的 [Union FS](https://en.wikipedia.org/wiki/Union_mount) 等技术，对进程进行封装隔离，属于 [操作系统层面的虚拟化技术](https://en.wikipedia.org/wiki/Operating-system-level_virtualization)。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101903479.png" alt="img" style="zoom:50%;" />

**Docker** 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 `Docker` 技术比虚拟机技术更为轻便、快捷。



## 为什么用Docker

- 更高效的利用系统资源
- 更快速的启动时间
- 一致的运行环境
- 持续交付和部署
- 更轻松的迁移
- 更轻松的维护和扩展



## 基本概念（镜像/容器/仓库）

### 镜像

操作系统分为 **内核** 和 **用户空间**。对于 `Linux` 而言，内核启动后，会挂载 `root` 文件系统为其提供用户空间支持。而 **Docker 镜像**（`Image`），就相当于是一个 `root` 文件系统。比如官方镜像 `ubuntu:18.04` 就包含了完整的一套 Ubuntu 18.04 最小系统的 `root` 文件系统。

**Docker 镜像** 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 **不包含** 任何动态数据，其内容在构建之后也不会被改变。

### 容器

镜像（`Image`）和容器（`Container`）的关系，就像是面向对象程序设计中的 `类` 和 `实例` 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 [命名空间](https://en.wikipedia.org/wiki/Linux_namespaces)。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。

按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 [数据卷（Volume）]()、或者 [绑定宿主目录]()，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。

### 仓库

镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，[Docker Registry]() 就是这样的服务。

一个 **Docker Registry** 中可以包含多个 **仓库**（`Repository`）；每个仓库可以包含多个 **标签**（`Tag`）；每个标签对应一个镜像。

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签。

以 [Ubuntu 镜像](https://hub.docker.com/_/ubuntu) 为例，`ubuntu` 是仓库的名字，其内包含有不同的版本标签，如，`16.04`, `18.04`。我们可以通过 `ubuntu:16.04`，或者 `ubuntu:18.04` 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 `ubuntu`，那将视为 `ubuntu:latest`。

仓库名经常以 *两段式路径* 形式出现，比如 `jwilder/nginx-proxy`，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。



## 安装

### CentOS

#### 卸载旧版本

Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 `overlay2` 存储层驱动）无法使用，并且部分功能可能不太稳定。

```shell
sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-selinux \
                  docker-engine-selinux \
                  docker-engine
```

#### 脚本自动安装

在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 `--mirror` 选项使用国内源进行安装：

```shell
# 下载脚本
curl -fsSL get.docker.com -o get-docker.sh
# 运行脚本 --mirror 选项使用国内源进行安装
sudo sh get-docker.sh --mirror Aliyun
```

#### yum安装

```shell
# 安装依赖包
sudo yum install -y yum-utils
# 添加 yum 国内软件源 效果就是下载一个aliyun的docker-ce.repo 配置在本地的/etc/yum.respos.d
sudo yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
sudo sed -i 's/download.docker.com/mirrors.aliyun.com\/docker-ce/g' /etc/yum.repos.d/docker-ce.repo
# 安装
sudo yum install docker-ce docker-ce-cli containerd.io
### 查看docker版本
docker --version 
```

#### CentOS额外设置

由于 CentOS8 防火墙使用了 `nftables`，但 Docker 尚未支持 `nftables`， 我们可以使用如下设置使用 `iptables`

```shell
vim /etc/firewalld/firewalld.conf
# 改为 FirewallBackend=iptables
# 或者
firewall-cmd --permanent --zone=trusted --add-interface=docker0
firewall-cmd --reload
```

#### 启动

```shell
# 设置开机启动
systemctl enable docker
# 启动
systemctl start docker
```

#### 创建docker用户组

默认情况下，`docker` 命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。

```shell
groupadd docker
# 将当前用户加入docker 组
sudo usermod -aG docker $USER
```

#### 测试是否安装正确

```shell
docker run --rm hello-world
```

![image-20211220152924484](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101903499.png)

### Windows10

待补充



## 基础使用

### 镜像

#### 拉取镜像

```powershell
docker pull
# Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号]。默认地址是 Docker Hub(docker.io)。
# 仓库名：仓库名是两段式名称，即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。
# 如从 Docker Hub （docker.io）获取镜像,获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像,镜像名称是 ubuntu:18.04,
docker pull ubuntu:18.04
```

#### 运行镜像

```powershell
docker run
# -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。打算进入 bash 执行一些命令并查看返回结果，因此需要交互式终端。
# --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。如果只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。
# 如 用 ubuntu:18.04 镜像为基础来启动容器,执行命令bash
docker run -it --rm ubuntu:18.04 bash
# 进入后，可以执行shell指令
```

#### 查看镜像

```powershell
docker image ls
# 列出已下载镜像
# 包含了 仓库名REPOSITORY、标签TAG、镜像 IDIMAGE ID、创建时间CREATED 以及 所占用的空间SIZE。
docker image ls ubuntu:18.04 # 列出ubuntu仓库名18.04标签的镜像
# -filter 简写-f 过滤参数
docker image ls -f since=mongo:3.2 # 看到在 mongo:3.2 之后建立的镜像
docker system df # 查看镜像、容器、数据卷所占用的空间
```

**镜像 ID** 则是镜像的唯一标识，一个镜像可以对应多个 **标签**。不同标签相同id的镜像意味着是同一个镜像。

> - ##### 虚悬镜像
>
>   拉取新镜像与原镜像同名，原镜像名称被取消，一般可以删除，仓库名、标签均为 `<none>`
>
>   ```powershell
>   docker image ls -f dangling=true # 查看虚悬镜像
>   docker image prune # 删除虚悬镜像
>   ```
>
> - ##### 中间层镜像
>
>   被重复利用的资源，使用一段时间后，会产生依赖的中间层镜像，表现为无标签，不应该删除，否则影响被依赖的镜像。删除依赖它的镜像，自然会被删除。
>
>   ```powershell
>   docker image ls -a #列出镜像包含中间层的
>   ```

#### 删除本地镜像

```powershell
# docker image rm [选项] <镜像1> [<镜像2> ...]
docker image rm 501ad78535f0  # 删除镜像id的镜像，可以缩写为501 在保证足够区分镜像的前提下
docker image rm centos # 按镜像名删除

# 停止相关的镜像
docker ps -a | grep "Exited" | awk '{print $1 }'|xargs docker stop
docker ps -a | grep "Exited" | awk '{print $1 }'|xargs docker rm
# 刪除鏡像
docker images|grep none|awk '{print $3 }'|xargs docker rmi
```



### 容器

#### 启动

```powershell
docker run #新建并启动
docker run ubuntu:18.04 /bin/echo 'Hello world' # 启动容器 打印并终止
# -t 让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上
# -i 让容器的标准输入保持打开
docker run -t -i ubuntu:18.04 /bin/bash # 启动一个bash终端,允许用户进行交互。

docker container start #启动已终止容器
```

> 当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：
>
> - 检查本地是否存在指定的镜像，不存在就从 [仓库]() 下载
> - 利用镜像创建并启动一个容器
> - 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层
> - 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
> - 从地址池配置一个 ip 地址给容器
> - 执行用户指定的应用程序
> - 执行完毕后容器被终止

#### 守护态运行

```powershell
# -d 启动时添加 让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下
# 使用 -d 参数启动后会返回一个唯一的 id，也可以通过命令来查看容器信息。
docker container ls
# 查看守护态容器返回信息
docker container logs 
```

#### 终止

```powershell
docker container stop # 终止一个运行中的容器
# 当 Docker 容器中指定的应用终结时，容器也自动终止
docker container ls -a # 查看终止状态容器
docker container restart # 终止容器再进行启动
```

#### 进入容器

```powershell
docker attach # 进入容器后 使用exit指令会导致容器终止
docker exec # -i 没有分配伪终端，没有熟悉的 Linux 命令提示符;-it 一起使用可以看到linux命令提示符 
# 推荐使用exec，exit不会导致终止。
```

#### 导入导出

```powershell
docker export # 导出
docker export 7691a814370e > ubuntu.tar  # 导出容器快照到本地文件

docker import # 导入 容器快照为镜像
cat ubuntu.tar | docker import - test/ubuntu:v1.0 
# 也可以通过指定 URL 或者某个目录来导入
docker import http://example.com/exampleimage.tgz example/imagerepo 
```

#### 删除

```powershell
docker container rm # 删除一个处于终止状态的容器
# -f 删除一个运行中的容器
docker container prune # 清理所有处于终止状态的容器
```

#### 查看容器

```powershell
docker ps
docker ps -a # 查看所有的容器,包括未运行的容器
```



### 仓库

#### 公共仓库

```powershell
# 在 https://hub.docker.com 免费注册一个 Docker 账号
docker login # 输入用户名及密码来完成在命令行界面登录 Docker Hub
docker logout # 退出登录
```

#### 拉取镜像

```powershell
docker search  # 查找官方仓库中的镜像
# --filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像
docker pull # 下载到本地
```

> - 基础镜像：类似 `centos` 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字
> - 用户镜像：比如 `ansible/centos7-ansible` 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 `username/` 来指定使用某个用户提供的镜像，比如 ansible 用户。

#### 推送镜像

```powershell
docker push # 命令来将自己的镜像推送到 Docker Hub
docker push username/ubuntu:18.04 # username 为Docker账号用户名
```



#### 私有仓库

[`docker-registry`](https://docs.docker.com/registry/) 是官方提供的工具，可以用于构建私有的镜像仓库。

- ##### 安装运行

  ```powershell
  docker run -d -p 5000:5000 --restart=always --name registry registry
  # 将使用官方的 registry 镜像来启动私有仓库
  # 默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下,可以通过 -v 参数来将镜像文件存放在本地的指定路径
  # 如将上传的镜像放到本地的 /opt/data/registry 目录
  docker run -d \
      -p 5000:5000 \
      -v /opt/data/registry:/var/lib/registry \
      registry
  ```

- ##### 私有仓库上传、搜索、下载镜像

  ```powershell
  docker tag # 标记一个镜像
  #  如将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest
  docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest 
  
  docker push # 上传标记的镜像
  docker push 127.0.0.1:5000/ubuntu:latest 
  
  # curl 查看仓库中的镜像
  curl 127.0.0.1:5000/v2/_catalog
  
  # 删除本地镜像
  docker image rm 127.0.0.1:5000/ubuntu:latest
  # 拉取本地镜像
  docker pull 127.0.0.1:5000/ubuntu:latest
  ```

- ##### 配置非 https 仓库地址

  ```powershell
  # Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制
  # 在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）
  # 必须符合 json 规范，否则 Docker 将不能启动
  {
    "registry-mirror": [
      "https://hub-mirror.c.163.com",
      "https://mirror.baidubce.com"
    ],
    "insecure-registries": [
      "192.168.199.100:5000"
    ]
  }
  ```

  

## 常用指令

```shell
#查看所有容器
docker ps -a   

#关闭容器
docker stop 容器名 

#启动容器
docker start 容器名

#删除容器(必须先关闭容器后才能删除)
docker rm 容器名

#查看所有镜像
docker images

#删除镜像
docker rmi 镜像ID 

#杀死运行的容器：
docker kill $(docker ps -a -q)

#删除所有容器：
docker rm $(docker ps -a -q)

#强制删除所有镜像
docker rmi -f  $(docker images -q)

# 进入容器
docker exec -it 容器名 bash
docker exec -it 容器名 /bin/sh  # alpine制作
```

其他收集的指令：

```shell
# 查看容器配置
docker inspect 容器名
```



## 补充

### 配置阿里云镜像加速器

- 登陆阿里云

  ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/20210122164353.png)

- 找到镜像加速器

  ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/220210122164635.png)

- 修改docker配置文件

  ```shell
  vim /etc/docker/daemon.json
  # 有就修改 没有就添加
  {"registry-mirrors": ["https://hub-mirror.c.163.com", "https://mirror.baidubce.com","刚申请的加速器地址"]}
  ```

  

## Docker Compose

Docker Compose是一个用于定义和运行多个docker容器应用的工具。使用Compose你可以用YAML文件来配置你的应用服务，然后使用一个命令，你就可以部署你配置的所有服务了。



### 安装

- 下载

  ```shell
  curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
  ```

- 修改该文件为可执行

  ```shell
  chmod +x /usr/local/bin/docker-compose
  ```

- 查看是否安装成功

  ```shell
  docker-compose --version
  ```

  ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/refer_screen_96.png)



### 使用Docker Compose的步骤

- 使用Dockerfile定义应用程序环境，一般需要修改初始镜像行为时才需要使用；
- 使用docker-compose.yml定义需要部署的应用程序服务，以便执行脚本一次性部署；
- 使用docker-compose up命令将所有应用服务一次性部署起来。

### docker-compose.yml常用命令

#### image

指定运行的镜像名称

```yaml
# 运行的是mysql5.7的镜像
image: mysql:5.7Copy to clipboardErrorCopied
```

#### container_name

```yaml
# 容器名称为mysql
container_name: mysqlCopy to clipboardErrorCopied
```

#### ports

指定宿主机和容器的端口映射（HOST:CONTAINER）

```yaml
# 将宿主机的3306端口映射到容器的3306端口
ports:
  - 3306:3306Copy to clipboardErrorCopied
```

#### volumes

将宿主机的文件或目录挂载到容器中（HOST:CONTAINER）

```yaml
# 将外部文件挂载到myql容器中
volumes:
  - /mydata/mysql/log:/var/log/mysql
  - /mydata/mysql/data:/var/lib/mysql
  - /mydata/mysql/conf:/etc/mysqlCopy to clipboardErrorCopied
```

#### environment

```yaml
# 设置mysqlroot帐号密码的环境变量
environment:
  - MYSQL_ROOT_PASSWORD=rootCopy to clipboardErrorCopied
```

#### links

连接其他容器的服务（SERVICE:ALIAS）

```yaml
# 可以以database为域名访问服务名称为db的容器
links:
  - db:databaseCopy to clipboardErrorCopied
```

#### restart

指定容器重启策略

```yaml
restart: always
```

| 策略                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| no                       | 不自动重启（默认模式）                                       |
| on-failure[:max-retries] | 重启因出错停止的容器（非0退出码）。可以通过指定max-retries来限定docker daemon的最大尝试重启次数 |
| always                   | docker daemon会无限尝试重启退出的容器（无论以什么退出码退出）。手动停止容器后，容器策略不再生效。除非重启docker daemon |
| unless-stopped           | 与`always`类似，区别在于手动停止容器后，就算重启docker daemon，容器策略也不再生效。 |



### 常用命令

#### 构建、创建、启动相关容器

```bash
# -d表示在后台运行
docker-compose up -dCopy to clipboardErrorCopied
```

#### 指定文件启动

```bash
docker-compose -f docker-compose.yml up -dCopy to clipboardErrorCopied
```

#### 停止所有相关容器

```bash
docker-compose stopCopy to clipboardErrorCopied
```

#### 列出所有容器信息

```bash
docker-compose ps
```



### 使用Docker Compose 部署应用





# 代理服务器-Nginx

高性能http服务器/反向代理服务器。

[Nginx中文官方文档](http://shouce.jb51.net/nginx-doc/)

**应用场景**

- http服务器：网页静态服务器
- 虚拟主机
- 反向代理，负载均衡



## 安装

### Linux

前提：CentOS7，操作用户有root权限

#### yum安装



#### 编译安装

[参考1](https://www.gaoxiaobo.com/web/server/143.html)

**环境**

```shell
#  gcc环境
yum install gcc gcc-c++
#  第三方开发包
yum install -y pcre pcre-devel
yum install -y zlib zlib-devel
yum install -y openssl openssl-devel
#  可能缺少的命令和工具包
yum install -y automake autoconf libtool make
```

应对可能出现的"Unit not found"，提前安装服务epel[^5]（后续证明没什么关系，只是自动安装时会用到）

```shell
yum -y install epel-release
yum clean all && yum makecache
```

**下载**

从[官网](http://nginx.org/en/download.html)将源码包nginx-1.18.0.tar.gz下载下来

**安装**

- 上传到linux系统或者下载

  ```shell
  wget http://nginx.org/download/nginx-1.18.0.tar.gz
  ```

- 解压缩 

  ```shell
  tar -zxvf nginx-1.18.0.tar.gz 
  ```

- 进入目录

  ```shell
  cd nginx-1.18.0
  ```

- 调用configure脚本创建自动化编译文件Makefile（不用编辑文件本身）

  ```shell
  ./configure \
  --with-http_stub_status_module \
  --with-http_gzip_static_module \
  --with-http_ssl_module \
  --with-http_flv_module \
  --with-http_realip_module \
  --with-http_v2_module \
  --user=nginx \
  --group=nginx \
  --with-pcre
  # 查看配置是否成功（0表示没有错误）
  echo $?
  ```

  如图，会自动创建objs目录与Makefile文件

  ![image-20210131172406769](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101903749.png)

- 编译&安装

  ```shell
  make && make install
  ```

- 测试安装成功与否

  ```shell
  nginx -v
  ```

- 移动到安装目录，启动nginx

  ```shell
  cd /usr/local/nginx/sbin
  ./nginx
  # 测试启动与否
  curl localhost
  # 监控启动端口 默认80
  netstat -tnlp
  ```

**添加到环境变量**

如果nginx指令不存在，则将其添加到环境变量

```shell
vim /etc/profile
# 编辑配置文件，为PATH后添加:/usr/local/nginx/sbin
source /etc/profile # 使配置生效
```

```shell
# 或者直接新建一个环境变量文件
vim /etc/profile.d/path.sh
export PATH=$PATH:/soft/nginx/sbin
source /etc/profile
```

**创建用户与组**

因为编译时指定了参数，需要有对应用户与组

```shell
# 启动时报错 nginx: [emerg] getpwnam("nginx") failed
groupadd -r nginx
useradd -r nginx -g nginx -s /sbin/nologin -M   # 创建的用户拒绝登录
```

并在安装后修改nginx.conf中的配置

```shell
vim /usr/local/nginx/conf/nginx.conf
# 修改 #user  nobody
# 为user nginx nginx
```

**创建配置目录**

因为编译时指定了部分目录，需要手动创建

```shell
#启动时报错 nginx: [emerg] mkdir() "/var/tmp/nginx/client/" failed (2: No such file or directory) 
#有的可能自动创建，但权限会缺失，所以手动创建
mkdir -p /var/tmp/nginx/client
mkdir /usr/local/nginx/logs
# 诸如此类 随机应变
```



> - configure命令参数解释  [参考](https://blog.csdn.net/wplblog/article/details/113124440)  [官方文档](http://nginx.org/en/docs/configure.html)
>
>   ```shell
>   ./configure \
>   # nginx安装目录，默认/usr/local/nginx   \为换行符，连行书写可省略
>   --prefix=/usr/local/nginx \  
>   # nginx可执行文件（启动脚本）的路径，默认prefix/sbin/nginx
>   --sbin-path=/usr/local/nginx/sbin/nginx \  
>   # nginx.conf配置文件路径，默认prefix/conf/nginx.conf
>   --conf-path=/usr/local/nginx/conf/nginx.conf \  
>   # nginx.pid文件路径名称（存储主进程号），默认prefix/logs/nginx.pid 设置自启的话不能用默认
>   --pid-path=/var/run/nginx/nginx.pid \  
>   # 共享存储器互斥锁文件路径（安装文件锁定，防止误操作），默认prefix/logs/nginx.lock
>   --lock-path=/var/lock/nginx.lock \
>   # 主错误/警告/诊断文件的路径名称，默认prefix/logs/error.log
>   --error-log-path=/var/log/nginx/error.log \
>   # 主请求的HTTP服务器的日志文件的路径名称，默认prefix/logs/access.log
>   --http-log-path=/var/log/nginx/access.log \
>   # nginx工作进程用户名，默认nobody
>   --user=nginx \
>   # nginx工作进程用户组，默认非特权用户
>   --group=nginx \
>   # 启用ngx_http_ssl_module支持（用来支持https请求，需已安装openssl）
>   --with-http_ssl_module \
>   # 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件，流媒体播放）
>   --with-http_flv_module \
>   # 后台Nginx服务器记录原始客户端的IP地址
>   --with-http_realip_module \
>   # 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态，监控用）
>   --with-http_stub_status_module \
>   # 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流，解压模块，需要zlib库）
>   --with-http_gzip_static_module \
>   --with-http_v2_module \
>   # 设定http客户端请求临时文件路径   默认prefix/client_body_temp
>   --http-client-body-temp-path=/var/tmp/nginx/client/ \
>   # 设定http代理临时文件路径
>   --http-proxy-temp-path=/var/tmp/nginx/proxy/ \
>   # 设定http fastcgi临时文件路径
>   --http-fastcgi-temp-path=/var/tmp/nginx/fastcgi/ \
>   # 设定http uwsgi临时文件路径
>   --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi/ \
>   # 设定http scgi临时文件路径
>   --http-scgi-temp-path=/var/tmp/nginx/scgi/ \
>   # 启用pcre库
>   --with-pcre
>   ```
>
> - 查看nginx编译参数：`nginx -V`
>
> - Makefile使用方法[相关文档](https://seisman.github.io/how-to-write-makefile/overview.html)

[^5]: yum的一个软件源,里面包含了许多基本源里没有的软件

### Windows





## 配置开机自启

默认Linux

### 法一（systemctl）

[参考1](https://segmentfault.com/a/1190000022665540) [参考2](https://blog.csdn.net/yuanfangPOET/article/details/90045001)

因为以上安装方式是手动编译安装，所以开机自启文件需要手动创建

- pid-path修改路径，不能设置为/var/run/nginx/nginx.pid。因为CentOS每次重启后，都会删除/var/run目录中的自建目录和文件，从而导致nginx自启动失败。

  补救措施：修改nginx.conf文件将下面一行代码的注释去掉

  ```nginx
  #pid        logs/nginx.pid;
  #这个路径是相对于安装路径的，也可以写成绝对路径/usr/local/nginx/logs/nginx.pid
  ```

  并创建目录 /usr/local/nginx/logs

  ```shell
  mkdir /usr/local/nginx/logs
  ```

- 创建nginx.service文件

  ```shell
  vim /lib/systemd/system/nginx.service
  ```

  内容为

  ```ini
  [Unit]
  Description=The nginx HTTP and reverse proxy server
  After=network.target remote-fs.target nss-lookup.target
    
  [Service]
  Type=forking
  ExecStartPre=/usr/local/nginx/sbin/nginx -t
  ExecStart=/usr/local/nginx/sbin/nginx
  ExecReload=/usr/local/nginx/sbin/nginx -s reload
  ExecStop=/usr/local/nginx/sbin/nginx -s stop
  PrivateTmp=true
    
  [Install]
  WantedBy=multi-user.target
  ```

  > - PIDFile：PID路径，按照编译配置的路径，就在/usr/local/nginx/logs/nginx.pid
  > - ExecStartPre：在执行ExecStart之前的操作，先删除有关nginx的PID也就是停止nginx，然后再检查nginx -t配置文件是否正确
  > - ExecStart：nginx启动操作，按照编译配置的路径，就在/usr/local/nginx/sbin/nginx
  > - ExecReload：nginx重启操作，这里HUP是平滑重启，重新加载配置文件
  > - ExecStop：nginx停止操作，实际是使用了QUIT从容关闭nginx
  > - 控制信号：
  >   - TERM, INT  快速关闭
  >   - QUIT  从容关闭
  >   - HUP  重新配置，从容关闭工作进程，开始新进程
  >   - WINCH 从容关闭工作进程
  > - Nginx 进程分为主进程(master process)和若干工作进程(work process)，其中工作进程指明了nginx要开启的进程数，一般为当前机器总cpu核心数的1到2倍。如，我的机器为双核，那么开4个足够了。

- 设置开机启动

  ```shell
  systemctl enable nginx.service
  ```

- 检查调试

  ```shell
  # 关闭之前开启的nginx并重启
  pkill -9 nginx
  service nginx start
  service nginx status
  #重启机器
  reboot
  #取消自启
  systemctl disable nginx.service
  #查看所有服务
  systemctl list-units --type=service
  ```

  

### 法二（rc.local）

[参考](https://juejin.cn/post/6844903929508020237)

不建议与上一个方法一起使用，会导致启动两次（第二次会失败）

```shell
# 给一个系统文件/etc/rc.d/rc.local 添加一行启动文件，就是nginx的启动程序
echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.d/rc.local
# 赋予这个系统文件执行权限（默认情况没有权限） +x相当于a+x
chmod +x /etc/rc.d/rc.local
```



### 法三

网上很多，类似法二，未经测试 [参考](https://www.nginx.com/resources/wiki/start/topics/examples/redhatnginxinit/)

- 创建文件/etc/init.d/nginx

  ```shell
  vi /etc/init.d/nginx
  ```

  文件内容（注意内置的nginx执行程序以及nginx.conf的位置配置）

  ```bash
  #!/bin/bash
  #
  # nginx - this script starts and stops the nginx daemon
  #
  # chkconfig: - 85 15
  # description: Nginx is an HTTP(S) server, HTTP(S) reverse \
  # proxy and IMAP/POP3 proxy server
  # processname: nginx
  # config: /usr/local/nginx/conf/nginx.conf
  # pidfile: /usr/local/nginx/logs/nginx.pid
  
  # Source function library.
  . /etc/rc.d/init.d/functions
  
  # Source networking configuration.
  . /etc/sysconfig/network
  
  # Check that networking is up.
  [ "$NETWORKING" = "no" ] && exit 0
  
  nginx="/usr/sbin/nginx"
  prog=$(basename $nginx)
  
  NGINX_CONF_FILE="/etc/nginx/nginx.conf"
  
  [ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginx
  
  lockfile=/var/lock/subsys/nginx
  
  make_dirs() {
     # make required directories
     user=`$nginx -V 2>&1 | grep "configure arguments:.*--user=" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -`
     if [ -n "$user" ]; then
        if [ -z "`grep $user /etc/passwd`" ]; then
           useradd -M -s /bin/nologin $user
        fi
        options=`$nginx -V 2>&1 | grep 'configure arguments:'`
        for opt in $options; do
            if [ `echo $opt | grep '.*-temp-path'` ]; then
                value=`echo $opt | cut -d "=" -f 2`
                if [ ! -d "$value" ]; then
                    # echo "creating" $value
                    mkdir -p $value && chown -R $user $value
                fi
            fi
         done
      fi
  }
  
  start() {
      [ -x $nginx ] || exit 5
      [ -f $NGINX_CONF_FILE ] || exit 6
      make_dirs
      echo -n $"Starting $prog: "
      daemon $nginx -c $NGINX_CONF_FILE
      retval=$?
      echo
      [ $retval -eq 0 ] && touch $lockfile
      return $retval
  }
  
  stop() {
      echo -n $"Stopping $prog: "
      killproc $prog -QUIT
      retval=$?
      echo
      [ $retval -eq 0 ] && rm -f $lockfile
      return $retval
  }
  
  restart() {
      configtest || return $?
      stop
      sleep 1
      start
  }
  
  reload() {
      configtest || return $?
      echo -n $"Reloading $prog: "
      killproc $prog -HUP
      retval=$?
      echo
  }
  
  force_reload() {
        restart
  }
  
  configtest() {
        $nginx -t -c $NGINX_CONF_FILE
  }
  
  rh_status() {
        status $prog
  }
  
  rh_status_q() {
        rh_status >/dev/null 2>&1
  }
  
  case "$1" in
  	start)
  		rh_status_q && exit 0
  		start
  		;;
  	stop)
  		rh_status_q || exit 0
  		$1
  		;;
  	restart|configtest)
  		$1
  		;;
  	reload)
  		rh_status_q || exit 7
  		$1
  		;;
  	force-reload)
  		force_reload
  		;;
  	status)
  		rh_status
  		;;
  	condrestart|try-restart)
  		rh_status_q || exit 0
  			;;
  	*)
  		echo $"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}"
  		exit 2
  esac
  ```

- 保存文件后修改文件权限

  ```shell
  chmod a+x /etc/init.d/nginx
  ```

- 将nginx加入chkconfig，设置开机启动

  ```shell
  chkconfig --add /etc/init.d/nginx
  chkconfig nginx on
  # 检查
  chkconfig --list nginx
  ```





## 卸载



### Linux

- 停止nginx，删除自启动

  ```shell
  service nginx stop
  systemctl disable nginx.service
  ```

- 搜索并删除nginx本地文件

  ```shell
  which nginx
  find / -name nginx*
  rm -rf /xxxxx  # 根据搜索结果删除
  ```

- yum卸载

  ```shell
  yum remove nginx
  ```

- 按照安装的方式修改配置的环境变量



## 常用命令

```shell
nginx  #启动nginx   -c 指定配置文件
nginx -s reload|reopen|stop|quit   #重新加载配置|重启|快速停止|安全关闭nginx
nginx -V #查看编译参数
nginx -v #查看版本
nginx -h #帮助
nginx -t #检查nginx.conf语法正确性
service nginx status #查看nginx状态
pkill -9 nginx #杀死nginx进程
```



## 配置文件

#### nginx.conf默认配置文件

```nginx
#全局块
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

#events块
events {
    worker_connections  1024;
}

#http块
http {
    #http全局块
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #server块
    server {
        #server全局块
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        #location块
        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
```

#### 分区功能

- **全局块：**配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。
- **events块：**配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。
- **http块：**可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。
- **server块：**配置虚拟主机的相关参数，一个http中可以有多个server，一个server相当于一个虚拟主机。
- **location块：**配置请求的路由，基于接收到的请求字符串，对特定请求进行处理。



#### 配置详解

[参考1](http://www.netkiller.cn/www/nginx/conf.html)

```nginx
########### 每个指令必须有分号结束。#################
#user nginx nginx;  #配置用户或者组，默认为nobody nobody。
#worker_processes 2;  #允许生成的进程数，默认为1(好像比较适合设为cpu核数的1~2倍)
#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址，默认/logs/nginx.pid
error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
events {
    accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on
    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off
    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    worker_connections  1024;    #最大连接数=连接数*进程数，默认为512
}
http {
    include       mime.types;   #文件扩展名与文件类型映射表
    default_type  application/octet-stream; #默认文件类型，默认为text/plain
    #access_log off; #取消服务日志    
    log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; #自定义格式
    access_log log/access.log myFormat;  #combined为日志格式的默认值
    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。
    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。
    #tcp_nopush     on;  #防止网络阻塞
    #keepalive_timeout  0; #长连接超时时间，单位是秒
    #gzip  on;  #开启gzip压缩输出
    
    upstream mysvr {   
      server 127.0.0.1:7878;
      server 192.168.10.121:3333 backup;  #热备
    }
    error_page 404 https://www.baidu.com; #错误页
    server {
        keepalive_requests 120; #单连接请求上限次数。
        listen       4545;   #监听端口
        server_name  127.0.0.1;   #监听地址
        
        #charset utf-8; #默认编码
        #access_log  logs/host.access.log  main; #定义本虚拟主机的访问日志
        
        location  ~*^.+$ {       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
           #root path;  #根目录
           #index vv.txt;  #设置默认页
           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表
           deny 127.0.0.1;  #拒绝的ip
           allow 172.18.5.54; #允许的ip           
        } 
    }
}
```

> - 惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。
> - 每个指令必须有分号结束。



##### 处理器配置

```nginx
user www;
worker_processes 1;

error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;
```



##### events配置

```nginx
events {
    worker_connections  4096;
}
```



##### http配置

###### 缓冲区相关配置

```nginx
client_body_buffer_size 1K;
client_header_buffer_size 1k;
client_max_body_size 1k;
large_client_header_buffers 2 1k;

server {
  ...
  client_max_body_size 200M;  #上传文件提示client intended to send too large body，配置参数可以解决。
}
```

###### 超时配置

```nginx
client_body_timeout 10;
client_header_timeout 10;
keepalive_timeout 65;
send_timeout 10;
```

###### gzip

```nginx
gzip on;
gzip_min_length 1000;
gzip_buffers 4 8k;
gzip_types text/plain text/css application/json application/x-javascript application/xml;


gzip on;
gzip_http_version 1.0;
gzip_disable "MSIE [1-6].";
gzip_types text/plain application/x-javascript text/css text/javascript;

#gzip压缩类型
# text/html 是 gzip_types 默认值，不要将text/html加入到gzip_types
gzip_types text/plain text/css application/javascript text/javascript application/x-javascript text/xml application/xml application/xml+rss application/json;
```

**CDN支持**

```nginx
# 配置 gzip_proxied any; 后CDN才能识别 gzip
server_tokens off;
gzip on;
gzip_types text/plain text/css application/javascript text/javascript application/x-javascript text/xml application/xml application/xml+rss application/json;
gzip_proxied any;
```

###### server_tokens

```nginx
http {
...
server_tokens off;  #隐藏nginx版本号
...
}
```



##### server

###### listen

```nginx
#绑定IP地址
listen 80; #相当于0.0.0.0:80监听所有接口上的IP地址
listen 192.168.0.1 80;
listen 192.168.0.1:80;
#配置默认主机 default_server
server {
    listen 80;
    server_name acc.example.net;
    ...
}
server {
    listen 80 default_server;
    server_name www.example.org;
    ...
}
```

###### server_name

```nginx
#绑定多个域名
server_name images.example.com img1.example.com img2.example.com;
#使用通配符匹配
server_name *.example.com
server_name www.*;
#正则匹配
server_name ~^(.+)\.example\.com$;
server_name ~^(www\.)?(.+)$;
#匹配所有域名
server_name _;
```

###### location

```nginx
location / {
    root /www;
    index index.html index.htm;
}

#禁止访问特定目录
location ~ /\.ht {
    deny  all;
}
location ~ ^/(config|include)/ {
    deny all;
    break;
}

#引用document_root之外的资源需要 root 绝对路径指向目标文件夹

```





##### Nginx 变量

可用的全局变量

```nginx
$args
$content_length
$content_type
$document_root
$document_uri
$host
$http_user_agent
$http_cookie
$http_referer
$limit_rate
$request_body_file
$request_method
$remote_addr
$remote_port
$remote_user
$request_filename
$request_uri
$query_string
$scheme
$server_protocol
$server_addr
$server_name
$server_port
$uri
```





## 代理



### 配置设置

- 



## 反向代理

### 概念

以代理服务器接收internet的连接请求，然后将请求转发给内部网络的服务器，将服务器返回的结果返回给internet的请求连接的客户端。

**正向代理示意图**

![image-20210131232307675](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101904967.png)

**反向代理示意图**

![image-20210131232344311](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101904065.png)

### 配置

修改文件：nginx.conf

[参考1](https://www.cnblogs.com/fanzhidongyzby/p/5194895.html)



#### 最简配置

示意：让访问nginx地址http://10.0.0.1:80/my的请求转发到my_server服务地址http://10.0.0.2:8080/

```nginx
# http节点下
upstream my_server {                                                         
    server 10.0.0.2:8080;                                                
    keepalive 2000;
}
server {
    listen       80;                                                         
    server_name  10.0.0.1;                                               
    client_max_body_size 1024M;

    location /my/ {
        proxy_pass http://my_server/;
        proxy_set_header Host $host:$server_port;
    }
}
```


> - 配置参数如果从
>
>   ```nginx
>   proxy_pass http://my_server/;
>   ```
>
>   改为
>
>   ```nginx
>   proxy_pass http://my_server;
>   ```
>
>   则http://10.0.0.1:80/my会转发到http://10.0.0.2:8080/my。这是因为proxy_pass参数中如果不包含url的路径，则会将location的pattern识别的路径作为绝对路径。



#### 重定向报文处理

当服务器进行重定向时，返回的信息会让浏览器发出绕开nginx服务器的访问，所以要配置让nginx能拦截此类请求，修改重定向返回的内容。

```nginx
location /my/ {
    proxy_pass http://my_server;
    proxy_set_header Host $host:$server_port;

	proxy_redirect / /my/;   
}
```

使用proxy_redirect可以修改重定向报文的location字段，

例子中会将所有的根路径下的url代理到nginx的/my/路径下返回给用户，

如服务返回的重定向报文的location原始值为/login，那么经过nginx代理后，用户收到的报文的location字段为/my/login，这样结合之前的配置一定会被nginx反向代理到应用服务器。

**需要注意的是**，服务返回的重定向报文的location字段有时会填写**绝对路径**（包含服务的ip/域名和端口），有时候会填写**相对路径**，此时需要根据实际情况进行甄别：

```nginx
location /my/ {
    proxy_pass http://my_server;
    proxy_set_header Host $host:$server_port;

	proxy_redirect http://my_server/ http://$host:$server_port/my/;
}
```

上述配置便是将my_server服务的根路径下的所有路径代理到nginx地址的/my/路径下



#### 报文数据替换

使用nginx代理有种比较复杂的情况就是http响应报文内写死了服务地址或web绝对路径。写死服务地址的情况比较少见，但也偶尔存在。最棘手的是写死了web绝对路径，尤其是绝对路径都没有公共前缀。

---

举个例子：

一般的web页面会包含如下类似路径：

- /public：用于静态页面资源，如js脚本/public/js，样式表/public/css，图片/public/img等。
- /static：和/public类似。
- /api：用于后台服务API接口。
- /login：用于登录验证。
- 其他。

对于这样的服务，可能的代理配置如下：

```nginx
location /my/ {
    proxy_pass http://my_server/;
    proxy_set_header Host $host:$server_port;

	proxy_redirect / /my/;
}
location /login/ {
    proxy_pass http://my_server/public;
    proxy_set_header Host $host:$server_port;
}
location /public/ {
    proxy_pass http://my_server/public;
    proxy_set_header Host $host:$server_port;
}
location /api/ {
    proxy_pass http://my_server/api;
    proxy_set_header Host $host:$server_port;
}
```

由于web页面或静态资源内写死了类似的绝对路径，那么对于用户来说，通过页面内的链接进行跳转时，都会请求到nginx服务对应的路径上。一旦存在另一个服务也包含类似的路径，也需要nginx进行代理，那么矛盾就出现了：**访问nginx的同一个路径下的请求究竟转发给哪一个服务？**

**解决方案**：在用户收到报文前，将报文的数据中包含的绝对路径都添加统一的前缀，如/my/public，/my/api

```nginx
location /my/ {
    proxy_pass http://my_server/;
    proxy_set_header Host $host:$server_port;

	proxy_redirect / /my/;
}
location /other/ {
    proxy_pass http://other_server/;
    proxy_set_header Host $host:$server_port;

	proxy_redirect / /other/;
}
```

nginx的ngx_http_sub_module模块提供了类似的报文数据替换功能，该模块默认不会安装，需要在编译nginx时添加--with-http_sub_module参数，或者直接下载nginx的[rpm](http://nginx.org/packages/mainline/rhel/6/x86_64/RPMS/)包。

使用sub_filter对数据包进行替换的语法如下：

```nginx
location /my/ {
	proxy_pass http://my_server/;
	proxy_set_header Host $host:$server_port;
	
	sub_filter 'href="/' 'href="/my/';
	sub_filter 'src="/' 'src="/my/';
	sub_filter_types text/html;
	sub_filter_once  off;
}
```

会将/my/下的所有响应报文内容的href="/替换为href="/my/，以及src="/替换为src="/my/，即为所有的绝对路径添加公共前缀。



### 补充配置

[参考](https://www.cnblogs.com/knowledgesea/p/5199046.html)  有错漏待补充

- 当代理遇到状态码为404时，我们把404页面导向百度

  ```nginx
  proxy_intercept_errors on;    #如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。
  error_page 404 https://www.baidu.com; #错误页
  ```

- 代理只允许接受get，post请求方法的一种

  ```nginx
  proxy_method get;    #支持客户端的请求方法。post/get；
  ```

- 避免轮询的服务器无法访问导致用户等待响应

  ```nginx
  proxy_connect_timeout 1;   #nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
  proxy_read_timeout 1; #nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒。
  proxy_send_timeout 1; #nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒。
  proxy_ignore_client_abort on;  #客户端断网时，nginx服务器是否忽略终端对被代理服务器的请求。默认为off。
  ```

- 如果使用upstream指令配置了一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理。

  ```nginx
  #反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off
  proxy_next_upstream timeout;  
  # error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误。
  # timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时。
  # invalid_header:被代理服务器返回的响应头异常。
  # off:无法将请求分发给被代理的服务器。
  # http_400，....:被代理服务器返回的状态码为400，500，502，等。
  ```

- 想通过http获取客户的真实ip而不是代理服务器的ip地址

  ```nginx
  #只要用户在浏览器中访问的域名绑定了 VIP VIP 下面有RS；则就用$host ；host是访问URL中的域名和端口  www.taobao.com:80
  proxy_set_header Host $host; 
  #把源IP 【$remote_addr,建立HTTP连接header里面的信息】赋值给X-Real-IP;这样在代码中 $X-Real-IP来获取 源IP
  proxy_set_header X-Real-IP $remote_addr;  
  #在nginx 作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来，用 【，】隔开；代码中用 echo $x-forwarded-for |awk -F, '{print $1}' 来作为源IP
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  ```

  







## 负载均衡

在网络现有结构之上可以提供一种廉价、有效、透明的方法来扩展网络设备和服务器的带宽，并可以在一定程度上增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性等。

充当着网络流中“交通指挥官”的角色，

“站在”服务器前处理所有服务器端和客户端之间的请求，从而最大程度地提高响应速率和容量利用率，同时确保任何服务器都没有超负荷工作。

如果单个服务器出现故障，负载均衡的方法会将流量重定向到其余的集群服务器，以保证服务的稳定性。

当新的服务器添加到服务器组后，也可通过负载均衡的方法使其开始自动处理客户端发来的请求。



### 负载均衡常用算法



#### 轮询

轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。

假设配置文件中共有 **M** 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。

**特点**

由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。

但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。



#### 加权轮询

加权轮询中，客户端的请求按权值比例分配，当一个请求到达时，优先为其分配权值最大的服务器。

每个服务器会有各自的 `weight`，一般情况下，`weight` 的值越大意味着该服务器的性能越好，可以承载更多的请求。

**特点**

加权轮询可以应用于服务器性能不等的集群中，使资源分配更加合理化。



#### IP 哈希

`ip_hash` 依据发出请求的客户端 IP 的 hash 值来分配服务器，该算法可以保证同 IP 发出的请求映射到同一服务器，或者具有相同 hash 值的不同 IP 映射到同一服务器。

**特点**

该算法在一定程度上解决了集群部署环境下 Session 不共享的问题。

> **Session 不共享问题**
>
> 假设用户已经登录过，此时发出的请求被分配到了 A 服务器，但 A 服务器突然宕机，用户的请求则会被转发到 B 服务器。但由于 Session 不共享，B 无法直接读取用户的登录信息来继续执行其他操作。



#### 其他算法

- URL hash

  `url_hash` 是根据请求的 URL 的 hash 值来分配服务器。该算法的特点是，相同 URL 的请求会分配给固定的服务器，当存在缓存的时候，效率一般较高。然而 Nginx 默认不支持这种负载均衡算法，需要依赖第三方库。

- 最小连接数

  当有新的请求出现时，遍历服务器节点列表并选取其中连接数最小的一台服务器来响应当前请求。连接数可以理解为当前处理的请求数。



### 初步应用配置

修改nginx.conf配置

nginx服务器端口为80，然后假设你的工作服务器有三个，端口分别为8081,8082,8083

```nginx
upstream testServer {
  server localhost:8081 weight=10;
  server localhost:8082 weight=2;
  server localhost:8083;
}

server {
    listen       80;
    server_name  localhost;

    location / {
        root   html;
        index  index.html index.htm;
        proxy_pass http://testServer;
    }
}
```

多次刷新可以发现，由于设置了不同的 `weight`，端口号为 8081 的服务器出现的次数最多。



### 实战补充



#### 热备

如果你有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB.....

```nginx
upstream mysvr { 
    server 127.0.0.1:7878; 
    server 192.168.10.121:3333 backup;  #热备     
}
```



#### 轮询

nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB....

```nginx
upstream mysvr { 
    server 127.0.0.1:7878;
    server 192.168.10.121:3333;       
}
```



#### 加权轮询

跟据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB....

```nginx
upstream mysvr { 
    server 127.0.0.1:7878 weight=1;
    server 192.168.10.121:3333 weight=2;
}
```



#### ip_hash

nginx会让相同的客户端ip请求相同的服务器。

```nginx
upstream mysvr { 
    server 127.0.0.1:7878; 
    server 192.168.10.121:3333;
    ip_hash;
}
```



#### 相关状态参数

- down  表示当前的server暂时不参与负载均衡。
- backup  预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。
- max_fails  允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。
- fail_timeout  在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。

```nginx
upstream mysvr { 
    server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;
    server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    
}
```



# 内网穿透-Frp(待补充)

frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。







# 服务器-Tomcat

## 安装



### Win

- 前提：  解压apache-tomcat-8.5.49.zip到指定路径。

- 环境变量配置：

  Path变量值添加 ;%CATALINA_HOME%\bin

  添加变量CATALINA_HOME，值为Tomcat安装位置，如E:\soft\apache-tomcat-8.5.49

- 检验安装

  进入到tomcat的安装目录bin目录下，控制台输入startup命令，服务器启动，同时本地可以访问localhost:8080即可



### Linux

```shell
# 下载 地址为https://tomcat.apache.org/
wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.107/bin/apache-tomcat-7.0.107.tar.gz
# 解压，放置在特定目录
tar -zxvf apache-tomcat-7.0.107.tar.gz -C /usr
# 启动 访问host:8080即可
cd /usr/apache-tomcat-7.0.107/bin
./startup.sh
#验证端口号占用情况
netstat -nalp|grep 8088
#关闭
./shutdown.sh
```

**配置到环境变量**

```shell
vim /etc/profile
# 添加 export CATALINA_HOME=/usr/apache-tomcat-7.0.107
# PATH的值后添加 :$CATALINA_HOME/bin
source /etc/profile
```



## 配置文件

[参考](https://www.cnblogs.com/kismetv/p/7228274.html)

以linux为例

```shell
vim /usr/apache-tomcat-7.0.107/conf/server.xml
```

```xml
<?xml version='1.0' encoding='utf-8'?>

<Server port="8005" shutdown="SHUTDOWN">
    <Listener className="org.apache.catalina.startup.VersionLoggerListener" />
    <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
    <Listener className="org.apache.catalina.core.JasperListener" />
    <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
    <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
    <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />


    <GlobalNamingResources>
        <Resource name="UserDatabase" auth="Container"
                  type="org.apache.catalina.UserDatabase"
                  description="User database that can be updated and saved"
                  factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
                  pathname="conf/tomcat-users.xml" />
    </GlobalNamingResources>

    <Service name="Catalina">

        <Connector port="8080" 
                   protocol="HTTP/1.1" 
                   connectionTimeout="20000" 
                   redirectPort="8443" />

        <Engine name="Catalina" defaultHost="localhost">
            
            <Realm className="org.apache.catalina.realm.LockOutRealm">
                <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
                       resourceName="UserDatabase"/>
            </Realm>

            <Host name="localhost"  
                  appBase="webapps"
                  unpackWARs="true" 
                  autoDeploy="true">

                <Valve className="org.apache.catalina.valves.AccessLogValve" 
                       directory="logs"
                       prefix="localhost_access_log." 
                       suffix=".txt"
                       pattern="%h %l %u %t &quot;%r&quot; %s %b" />

            </Host>
        </Engine>
    </Service>
</Server>

```

- `<Server port="8005" shutdown="SHUTDOWN">`唯一最外层元素，代表整个tomcat容器，可包含多个Service
  - shutdown 关闭Server的命令
  - port Server接收shuntdown指令的端口号，设为-1可禁用端口

- `<Service name="Catalina">`组装Connector和Engine，对外提供服务，可包含多个Connector，只能一个Engine

- name Service的名称

- ` <Connector port="8080" protocol="HTTP/1.1 connectionTimeout="20000" redirectPort="8443" />`接收请求，创建Request与Response用于交换数据，分配线程交给Engine处理请求

  - port 客户端访问tomcat的端口号，这里为8080
  - prototcol 访问tomcat使用的协议，这里为http
  - connectionTimeout 连接的超时时间
  - redirectPort 当强制要求https而请求是http，重定向至8443端口的Connector

- `<Engine name="Catalina" defaultHost="localhost">`Service组件中的请求处理组件，从一个或多个Connector中接收处理请求并返回响应。包含至少一个或多个Host容器。

  - name 用于日志和错误信息，在Server中唯一
  - defaultHost 指定了默认的host名称，匹配包含的Host组件name。如果请求的host名不存在则使用这个

- `<Host name="localhost"   appBase="webapps" unpackWARs="true"  autoDeploy="true">`代表Engine的一个虚拟主机，包含多个Context容器，对应安装、展开、启动、结束多个Web应用。

  - name 虚拟主机名，一般情况是DNS中注册的网络名（如”www.test.com”，或IP地址”116.25.25.25”）

  - unpackWARS 是否将代表Web应用的war解压，true解压，false直接用war运行
  - autoDeploy和appBase 与Host内Web应用的自动部署有关

- `<Context>` Host的子容器，代表特定虚拟主机运行的一个Web应用，基于war文件/war解压的应用目录

  - 文件没有出现这个部分，原因是自动部署，web应用通过特定规则被tomcat自动部署。



## 自动部署

  

### 开启web应用自动部署

#### Host配置

```xml
`<Host name="localhost"   appBase="webapps" unpackWARs="true"  autoDeploy="true">`
```

- Host节点的deployOnStartup和autoDeploy属性设为true，当检测到新的web应用/web应用更新，触发应用部署/重新部署。
  - deployOnStartup为true时，Tomcat在启动时检查Web应用，且检测到的所有Web应用视作新应用
  - autoDeploy为true时，Tomcat在运行时定期检查新的Web应用或Web应用的更新
- Host元素的appBase和xmlBase设置了检查Web应用更新的目录.
  - appBase指定Web应用所在目录，默认值webapps，指tomcat根目录下的webapps目录
  - xmlBase属性指定Web应用的XML配置文件所在的目录，默认值为conf/<engine_name>/<host_name>，如localhost的xmlBase默认值为$CATALINA_HOME/conf/Catalina/localhost

#### Web应用更新

一个web应用可能包含文件：xml配置，war包，应用目录（包含应用文件结构）

- xml配置文件位于xmlBase指定目录，war包和应用目录位于appBase指定目录
- tomcat按顺序扫描检查应用更新：xml配置文件，war包，应用目录

#### Context配置

主要包括  docBase 和 path 属性，以及reloadable属性也比较常用。

- docBase 指定应用使用的war路径或者应用目录路径。自动部署场景下，文件不在appBase中才指定这个。

- path 指定访问web应用上下文路径，请求到来时tomcat根据path和URI匹配选择应用处理请求。

  - 如app1应用path属性为"/app1"，app2应用path属性为"/app2"，
    则请求/app1/index.html交给app1，请求/app2/index.html交给app2。
  - 如果path属性为""，则为虚拟主机的默认应用，在请求的uri与所有path都不匹配时用它处理
  - 自动部署场景下，不能指定path属性，由 配置文件名/war文件名/应用目录名 自动推导出。
    如xmlBase目录下app1.xml，则应用path属性为"app1"；
    如果名称为ROOT，则为默认应用，path为""

- reloadable指示tomcat是否在运行时监控WEB-INF/classes和WEB-INF/lib目录下class文件的改动。

  为true则class变动时触发重新部署，一般用于开发环境调试；

  生产环境true会带来性能压力，所以默认为false。



**自动部署举例**

当我们安装完Tomcat后，$CATALINA_HOME/webapps目录下有如下文件夹：

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101904864.png)

启动后，可以使用http://localhost:8080/来访问Tomcat，访问的就是ROOT对应的Web应用。



# 版本控制-Git/GitLab/GitHub/gogs

## 安装Git

- 运行Git-2.24.0.2-64-bit_2.exe程序安装

- 在Git Bash界面输入指令配置

  ```bash
  # 全局配置用户名邮箱
  git config --global user.name "Sam"
  git config --global user.email "abcdef@163.com"
  # 意义不明的几个配置
  # push未指定分支默认push当前分支
  git config --global push.default simple
  # 解决中文转码问题
  git config --global core.quotepath false
  # 设置给git用vim为编辑器
  git config --global core.editor "vim"
  ```

## 配置GitHub

- 打开Git Bash输入以下指令

  ```bash
  # 清除现有ssh key 
  rm -rf ~/.ssh/*
  # 生成密钥，回车三次（自行查看）
  ssh-keygen -t rsa -b 4096 -C "邮箱"
  # 查看ssh key并复制查看的内容
  cat ~/.ssh/id_rsa.pub
  ```

- 进入github/settings/SSH Keys，选择new SSH Key将刚才复制的内容输入保存

- 回到Git Bash继续输入指令

  ```bash
  # 输入这个指令后，输入yes回车
  ssh -T git@github.com
  # 如果显示Permission Denied，说明失败，从第一步重开（清除SSH Key）
  # 如果是You've successfully authenticated, but GitHub does not provide shell access.说明成功
  ```

> - 一台电脑只需要一个 SSH key
> - 一个 SSH key 可以访问你的所有仓库，即使你有 1000000 个仓库，都没问题
> - 如果你新买了电脑，就在新电脑上重新生成一个 SSH key，把这个 key 也上传到 GitHub，它可以和之前的 key 共存在 GitHub 上
> - 如果你把 key 从电脑上删除了，重新生成一个 key 即可，替换之前的 key



## GitLab

### 安装

#### Linux

- 安装依赖包

  ```shell
  sudo yum install -y curl policycoreutils-python openssh-server
  yum install policycoreutils-python-utils
  # 如果是CentOs8 没有policycoreutils-python不影响
  ```

- 启动ssh并设置开机启动

  ```shell
  sudo systemctl start sshd
  sudo systemctl enable sshd
  ```

- 设置Postfix来发送通知邮件设置开机启动

  ```shell
  sudo yum install postfix
  sudo systemctl enable postfix
  ```

- 下载安装社区版

  ```shell
  wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el8/gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm
  rpm -i gitlab-ce-12.10.1-ce.0.el8.x86_64.rpm
  ```

  <img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101904127.png" alt="image-20220410023316209" style="zoom:50%;" />

- 编辑ip和端口

  ```shell
  vim /etc/gitlab/gitlab.rb
  # 设置公网ip+端口号
  ```

  ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101904187.png)

- 重启

  ```shell
  gitlab-ctl reconfigure
  gitlab-ctl restart
  ```

- 设置开机启动

  ```shell
  systemctl enable gitlab-runsvdir.service
  ```



#### Docker

- 拉取镜像 https://hub.docker.com/r/gitlab/gitlab-ce

  ```shell
  docker pull gitlab/gitlab-ce:latest
  ```

  中文社区版 https://gitlab.com/xhang/gitlab

- 创建容器

  通常会将 GitLab 的配置 (etc) 、 日志 (log) 、数据 (data) 放到容器之外， 便于日后升级，要先准备这三个目录。

  ```shell
  # 根据当前位置映射目录，也可以直接设置好目录 注意端口号开放
  docker run -d \
  --name gitlab \
  -u root \
  -p 10022:22 \
  -p 10080:80 \
  -p 10443:443 \
  -v $PWD/gitlab/etc:/etc/gitlab \
  -v $PWD/gitlab/log:/var/log/gitlab \
  -v $PWD/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce:14.6.1-ce.0
  ```

  ```shell
  mkdir -p /soft/gitlab
  # 个人没有开放22端口和443端口 重启策略是unless-stopped
  docker run --detach \
  --name gitlab \
  -u root \
  --publish 40080:80 \
  --restart unless-stopped \
  --volume /soft/gitlab/etc:/etc/gitlab \
  --volume /soft/gitlab/log:/var/log/gitlab \
  --volume /soft/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce:latest
  ```

- 修改配置文件，同直接安装，位置是/etc/gitlab/gitlab.rb映射到外部的位置，或者进入容器编辑

  ```shell
  docker exec -it gitlab bash
  vi /etc/gitlab/gitlab.rb
  # 或者
  vi /soft/gitlab/etc/gitlab.rb
  # 编辑EXTERNAL_URL
  ```

- 重启容器

  ```shell
  docker restart gitlab
  ```

- 确定端口已经开放后 直接访问即可 http://ip:40080

> 个人感觉用容器的一个好处在于如果一个服务占用了多个端口，可以用这种方式相互隔离，不影响其他程序使用端口。



### 修改Gitlab端口占用/域名映射

即使设置了EXTERNAL_URL，gitlab默认依然会占用8080端口，有时候不想让它占用，可以进行修改。[参考](https://stackoverflow.com/questions/29320022/gitlab-on-port-8080)

```shell
# 查询哪个程序监听了8080端口 -- unicorn master
netstat -lnp | grep 8080
# 查看gitlab.rb文件  原因是unicorn默认监听8080端口 修改gitlab.rb配置文件
vim /etc/gitlab/gitlab.rb
unicorn['port'] = 8079 # 自定义
gitlab_workhorse['auth_backend'] = "http://localhost:8079"
gitlab_pages['http_proxy'] = "http://example:8079"
puma['port'] = 8079
# 注意unicorn 和 gitlab_workhorse 不要和EXTERNAL_URL一样，这两者可以一样，并且要开放防火墙
# 修改gitlab访问端口改这个
nginx['listen_port'] = 8099
# external_url 这个是项目拷贝地址显示的
```

![image-20220415180349647](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220415180349647.png)

```shell
# 重启
sudo gitlab-ctl reconfigure
sudo gitlab-ctl restart
```



### 其他操作

#### 获取初始密码

刚安装24小时内可以查看文件获取初始密码

```shell
# 如果是容器查看对应映射位置
cat /etc/gitlab/initial_root_password 
```



#### 重置密码

```bash
# 使用root权限进入ruby控制台
sudo gitlab-rails console -e production
# 搜索用户信息
#按邮箱搜索
user=User.where(email:'lize_666@163.com').first  
#按id搜索 1是超级管理员
user=User.where(id:1).first  
#搜索到用户后修改用户密码，确认密码，保存
user.password=12345678 
user.password_confirmation=12345678
user.save!
```

#### nginx代理Gitlab后显示403

意图在gitlab不使用80端口的情况下访问80通过nginx反向代理到gitlab，结果显示403

原因是gitlab 有个同一 ip 用错误的用户名密码单位时间内多次访问 gitlab 的限制，解决方案：

- 修改gitlab配置文件,把nginx的ip地址加入白名单

  ```shell
  vim /etc/gitlab/gitlab.rb
  # 将本机外网ip加入gitlab白名单
  gitlab_rails['rack_attack_git_basic_auth'] = {
     'enabled' => true,
     'ip_whitelist' => ["127.0.0.1","<你的 nginx 机器 ip>","localhost"],
     'maxretry' => 10,
     'findtime' => 60,
     'bantime' => 3600
  }
  # 或者关闭ip限制功能
  gitlab_rails['rack_attack_git_basic_auth'] = {
     'enabled' => false,
     'ip_whitelist' => ["127.0.0.1","localhost"],
     'maxretry' => 10,
     'findtime' => 60,
     'bantime' => 3600
  }
  # 重启
  sudo gitlab-ctl reconfigure
  sudo gitlab-ctl restart
  ```

- 或者配置nginx代理的时候将ip地址传过来，而不是用代理的ip

  ```nginx
      server {
          listen      80;
          server_name ***.***.cn;
          location / {
            proxy_pass   http://localhost:8099;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          }
      }
  ```

  

## 利用docker快速搭建gogs

[参考视频](https://www.bilibili.com/video/BV1WE411K7Jb?from=search&seid=13783704422414342173&spm_id_from=333.337.0.0)

- 使用轻量级gogs服务

  ```powershell
  docker pull gogs/gogs
  ```

- 使用镜像创建容器

  ```powershell
  # 将宿主机的10022端口映射到容器的22端口，将宿主机的13000端口映射到容器的3000端口，10022端口和13000端口可以根据自己的情况修改
  sudo docker run -d -p 10022:22 -p 13000:3000 -v /root/gogs:/data gogs/gogs
  ```

  > - 22端口是gogs的ssh服务端口，如果不开启ssh服务，可不做这个端口映射
  > - 3000是gogs应用服务端口
  > - -v 指定本地持久化目录，对应镜像内的/data文件夹，是gogs的数据目录
  > - 注：10080端口公网访问会被浏览器自动拦截，请自行处理

- 启动容器，通过浏览器访问13000端口

- 在页面进行配置，选择数据库

  <img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101904707.png" alt="img" style="zoom: 80%;" />

  > - 如果使用 MySQL，请使用 INNODB 引擎以及 utf8_general_ci 字符集。
  > - 配置建议：
  >   - 应用名称：可以换成自定义名称
  >   - 仓库根目录：使用默认就行了，默认/data/git/gogs-repositories，如果采用了数据卷映射，比如因为/root/gogs映射/data，所以这个目录在宿主机中的地址是/root/gogs/git/gogs-repositories
  >   - 运行系统用户：不要修改，默认就是git用户，修改可能会有问题
  >   - 域名：使用ssh时使用的域名或者IP
  >   - SSH 端口号：gogs启用ssh时使用的端口号，默认22端口，如果修改了这个端口号，那么在上面创建容器时要对应的将10022端口映射到修改的端口号，如果不启用ssh，则置空
  >   - HTTP 端口号：gogs应用启动的http端口，默认3000，如果修改了这个端口号，那么在上面创建容器时要对应的将13000端口映射到修改的端口号
  >   - 应用 URL：即打开应用的url地址，因为这里采用了docker，所以我们要修改成宿主机的地址转发去访问，比如这里我的宿主机地址：192.168.209.128，它的13000端口会转发到容器的3000端口，所以这里填：http://192.168.209.128:13000/　　
  >   - 日志路径：gogs的日志保存路径，默认就行了

- 安装后访问13000端口

  ![image-20220110014712770](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202204101905248.png)

> - 默认注册的第一个账号为管理员账号









# jenkins自动化部署



# Arthas生产问题排查

“阿尔萨斯”



# DTS数据库迁移工具



# Sharding-JDBC读写分离


# 授权认证



## 概念/术语解释

### 认证（Identification）

指根据声明者所特有的识别信息，确认声明者的身份。

> 白话文的意思就是：**你需要用身份证证明你自己是你自己**。

生活中的一些认证：

- 身份证
- 用户名密码
- 用户手机号和验证码
- 人脸识别
- 指纹

### 授权（Authorization）

在信息安全领域是指**资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便对资源的相关操作**。

- 现实生活：银行卡、门禁卡、钥匙
- 互联网领域：session、cookie、token



### 鉴权（Authentication）

在信息安全领域是指**对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程**。

> 授权和鉴权是两个上下游相匹配的关系，**先授权，后鉴权**。

- 现实生活：刷门禁卡的门禁卡识别器，门锁
- 互联网领域：校验session/cookie/token的合法性有效性

鉴权通过便是获得权限，为后续的权限控制做准备。



### 权限控制（Access/Permission Control）

将可执行的操作定义为权限列表，然后判断操作是否允许/禁止。

权限是抽象的逻辑概念；控制是具体的实现方式。

- 现实生活：门禁卡有出入公司大门的权限；管理员的门禁卡有打开公司所有门的权限
- 互联网领域：web后端控制接口和页面的访问权限





## HTTP基本认证

基本认证方案（Basic Access Authentication）是允许 HTTP 用户代理（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。

### 要素

基本认证中，最关键的三个要素：

- **uid**	用户ID，也就是用户名
- **password**	密码
- **realm**	领域，指当前认证的包含范围



### 认证标识

进行基本认证的过程中，HTTP 的请求头字段会包含 Authorization 字段

```yaml
Authorization: Basic <用户凭证>
```

该用户凭证是 用户名 和 密码 的组合而成的 **Base64 编码**。

```sh
GET /securefiles/ HTTP/1.1
Host: www.example.com
Authorization: Basic aHR0cHdhdGNoOmY=
```



### 流程

1. 客户端请求一个受限制的网页资源，且没有提供用户身份信息

2. 服务端返回401 应答码（Unauthorized，未被授权的）要求进行身份验证，并附带提供了一个认证域（Access Authentication）`WWW-Authenticate` 说明如何进行验证的方法，如：

   ```yaml
   WWW-Authenticate: Basic realm="Secure Area"
   ```

   - Basic：指验证模式
   - realm="Secure Area"：指保护域，即认证的范围，标识认证只在这个范围有效，比如一个域名。

3. 客户端收到响应，会弹出认证域（比如弹窗）提示用户输入用户名和密码，用户选择录入信息确认或者取消。

4. 用户输入用户名和密码后，客户端会在原来的资源请求接口增加认证消息字段`Authorization`，并重新发送请求。

   - 用户名和密码拼接为`uid:password`格式
   - 如果`WWW-Authenticate`中有指定编码，则将字符编译为指定编码
   - 将字符编译为Base64
   - 在字符前拼接`Basic`

   ```js
   //	比如用户名admin 密码password  用js计算
   'Basic '+window.btoa('admin:password');
   > 'Basic YWRtaW46cGFzc3dvcmQ='
   ```

5. 服务端接收到认证信息，认证通过则返回用户请求的资源；认证非法或者无效，则再次返回401码，需要再次输入用户名密码。

   > 服务端验证的方式：
   >
   > - 根据用户请求的资源地址，获取资源的realm
   > - 解析Authorization 请求头，获取用户名密码
   > - 判断用户是否有realm的权限
   > - 判断用户名密码是否匹配

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209191419417.jpeg" alt="HTTP 基本认证流程图" style="zoom:50%;" />

### 优缺点

**优点**

实现简单，被浏览器广泛支持

**缺点**

- 用户名密码以明文在网络传输，容易被嗅探器探测到，所以基本验证方案并不安全

- Base64 编码并非加密算法，其无法保证安全与隐私，这里仅用于将用户名和密码中的不兼容的字符转换为均与 HTTP 协议兼容的字符集

- 即使认证内容无法被解码为原始的用户名和密码也是不安全的，恶意用户可以在获取了认证内容后使用其不断的向服务器发起请求，就是所谓的**重放攻击**

- Basic 认证还存在无法吊销认证的情况

  > HTTP 协议没有提供机制清除浏览器中的 Basic 认证信息，除非标签页或浏览器关闭、或用户清除历史记录



## Session-Cookie认证

Session-Cookie认证是利用服务端的 Session（会话）和 浏览器（客户端） 的 Cookie 来实现的前后端通信认证模式。

### Cookie

HTTP是无状态协议，

> **无状态协议**
>
> 对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息
>
> 个人理解：两次请求之间没有连续性，互不相关，我不知道上一次跟你聊天说了什么，哪怕是刚说的。

所以为了让服务器识别不同的请求可能来自同一个客户端，需要主动取维护一个状态来进行标识，而这个标识就是Cookie。

**特点**

- 存储在客户端，可以被篡改
- 大小有限制，4k
- 数目有限制，一般浏览器一个网站只能存不超过20个。总共只能存300个。
- 手机端对cookie支持性不好
- 不可跨域，但一二级域名允许共享（通过domain）

**用途**

- 会话状态管理：用户登陆状态、购物车、分数等要记录的信息
- 个性化设置：如自定义主题、自定义设置
- 行为追踪：跟踪用户行为等

**限制**
Cookie 是仅在浏览器中存在的报文字段，诸如移动原生 APP 是无法解析存储 Cookie 请求/响应头的。



### Session

抽象概念为会话，为了实现无状态通信过程中中断/继续操作，将用户与服务器交互进行的一种抽象。

具体来说，是服务器生成的一种保存用户会话的session结构，以内存、数据库、文件等方式进行存储。

**使用流程**

1. 客户端向服务器发出首次请求
2. 服务器接收数据，自动为用户创建唯一session/sessionId，标识用户，并用来追踪用户会话过程
3. 浏览器收到响应以及会话相关标识，后续请求会带上session/sessionId
4. 服务器接收数据，提取session与本地保存的session对比，找到用户对应的会话，进而维持会话状态

从而实现客户端与服务器的有状态通信。

**特点**

- session保存在服务器
- 通过服务器自带加密协议完成

**与cookie的区别**

- **安全性**	session存在服务器，无法伪造，安全性更高
- **存储值类型**	cookie只能存字符串，session存储任意类型
- **有效期**	cookie可长时间保持，session一般有效期较短
- **存储容量**	cookie不超过4k



### 流程

1. 服务器接收到客户端首次的访问，会自动创建session，为session生成唯一标识session_id作为身份凭证，并在响应头`Set-Cookie`中设置返回。
2. 这个session_id可能会在传递前通过密钥`secret`加密，前端传递后也会用这个解密。（非必要步骤）
3. 客户端接收并解析响应，将session_id保存在本地cookie中，并在下次http请求时，附带上域名下的所有cookie信息。
4. 服务端接收客户端请求时，会解析请求头的cookie，从中拿到session_id并在自身存储中查找，判断请求是否合法。
5. 用户一旦登出，服务端与客户端都会销毁各自保存的会话id，再次使用这个session_id则视为未通过。

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209191522075.jpeg" alt="Session-Cookie 认证流程图" style="zoom:67%;" />



### 优缺点

**优点**

- cookie简单易用，不被干预和过期处理的情况下，是客户端存储时间最长的数据保存形式
- session存储在服务端，相较于jwt方便管理，只在用户登录和注销时进行增删即可

**缺点**

- 不安全，cookie数据暴露在浏览器，存在被盗风险，以及CSRF攻击

  > **CSRF攻击**
  >
  > 跨站请求伪造 (Cross-site request forgery)
  >
  > 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
  >
  > 个人理解：大概是黑客引导用户带着cookie做了黑客想做的事情，因为cookie所以通过了认证但并非用户本意。比如点开垃圾邮件执行了脚本发送转发邮件的请求，此时是带着认证的，于是服务器通过并将用户的邮件转发给了黑客。

- session存储在服务端，增加了服务器的开销，用户量大时会大大降低服务器性能

- 用户认证后，服务器做认证记录，如果认证记录存在内存，则在集群情况下仅限当前服务器可通过用户认证，否则需要所有集群机器同步记录，限制了负载均衡的能力和应用的扩展能力。

### 应用场景

- 大中型网站，除了移动端
- session一般存在内存服务器上（如Redis），所以预算不足谨慎考虑



## Token认证



### Token

`Token` 是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。

一句话概括；**访问资源接口（API）时所需要的资源凭证**

与sessionId不同，token一般会包含用户相关的信息，通过token验证不仅可以完成身份验证，还可以获取预设信息，如用户名、性别等。

像 Twitter、微信、QQ、Github 等公有 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。



### 流程

1. 用户输入登录信息并登录

2. 服务端接收登录，请求验证登录信息

3. 验证通过后，服务端**签发**一个Token（包含用户基础信息、权限范围和有效期等），并将Token返回客户端

4. 客户端收到Token，需要将其存储起来，比如localStorage或sessionStorage中

   > - 一般不放 Cookie 因为可能会有跨域问题，以及安全性问题
   > - sessionStorage仅在当前窗口有效，关闭后失效；localStorage始终有效，可作为持久数据
   > - sessionStorage在不同窗口不共享；localStorage在所有同源窗口共享

5. 后续客户端向服务端请求资源时，需将token附带在请求头中发送

   > 一般是放在Authorization 字段

6. 服务端收到请求，校验Token，验证成功则返回数据，否则不返回

![Token 认证流程图](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209191543241.jpeg)



### 优缺点

**优点**

- **服务端无状态**	不需要服务端存储会话信息，因为token中附带了用户标识，有利于多个服务共享用户状态

- **性能较好**	验证token不用再查数据库，或者远程服务进行权限校验，性能提升

- 支持移动设备

- 支持跨域调用

- 避免CSRF攻击，因为不需要cookie，需要主动添加请求头。

- 存在XSS攻击中被盗风险，但可以将token存在`httponly`的cookie，避免js脚本修改cookie

  > **XSS攻击**
  >
  > 跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。 若受害者运行这些恶意代码，攻击者就可以突破网站的访问限制并冒充受害者。 
  >
  > **httponly**
  > HttpOnly是包含在Set-Cookie HTTP响应头文件中的附加标志。生成cookie时使用HttpOnly标志有助于降低客户端脚本访问受保护cookie的风险（如果浏览器支持）。
  >
  > 就是说，如果某一个Cookie 选项被设置成 HttpOnly = true 的话，那此Cookie 只能通过服务器端修改，Js 是操作不了的，对于 document.cookie 来说是透明的。
  >
  > 原理是httponly的cookie在前端通过api是获取不到的，自然无法修改。

**缺点**

- 占用带宽：token一般来说是比sessionId大的，自然传输的数据量更大
- 性能问题：需要服务端花费时间和性能进行token解密验证，相较于session-cookie实际是一个时间换空间的方案。



### 与Session-Cookie的区别

`Token` 更像是 `Session-Cookie` 的升级改良版。

- **标识存储位置**	 Session 一般是存储在服务端；Token 是无状态的，一般由前端存储；
- **安全性**	 Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击；
- **支持性**	 Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。



### 实现方案：JWT

JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。



#### 组成

JWT 是 JSON 格式的被加密了的字符串：

JWT token的格式：header.payload.signature

##### header 头部

用于描述关于该 JWT 的最基本的信息，包括类别（typ）、加密算法（alg）

```json
//	这是一个 JWT，并且使用的签名算法是 HS256 算法
{
  "alg": "HS256",
  "typ": "JWT"
}
```

进行 Base64 编码后得到一个字符串，作为header

##### payload/claims 载荷

包括需要传递的用户信息，

可以用来存放一些不敏感的信息

```json
{
  "iss": "Jehoshaphat Tse",
  "iat": 1441593502,
  "exp": 1441594722,
  "aud": "www.example.com",
  "sub": "mrsingsing@example.com",
  "name": "John Doe",
  "admin": true
}
```

这里面的前五个字段都是由 JWT 的标准所定义的:

- `iss`：该 JWT 的签发者
- `sub`：该 JWT 所面向的用户
- `aud`：接收该 JWT 的一方
- `exp`（expires）：什么时候过期，这是 Unix 时间戳
- `iat`（issued at）：在什么时候签发的。

进行 Base64 编码后得到一个字符串，作为payload

##### signature 签名

为以header和payload生成的签名，可以保证消息不被篡改，一旦header和payload被篡改，验证将失败。

将header和payload拼接后，用alg指定算法，以及私钥secret进行加密，加密后内容为字符串，即签名，拼在最后。

```java
//	secret为加密算法的密钥 加密算法HMACSHA256与Header里同步
String signature = HMACSHA256(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)
```



#### 实例

在该网站上获得解析结果：https://jwt.io/

如：

```sh
eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBw
```

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_13.fc3ff0ff.png)



#### 优缺点

**优点**

- token的优点
- jwt的载荷payload可以存储常用信息，用于信息交换，减少服务端查询数据库的频率

**缺点**

- **缺少手动过期策略**：服务端不保存session，则jwt一旦签发，不到过期时间就始终有效（还存在未设过期时间的情况），做不到提前踢下线这样的功能。如果这样，则需要设计一套主动删除jwt的机制，增加系统复杂性。
- **安全性**：载荷是Base64编码，没有加密，不能存储敏感信息
- **性能问题**：jwt超长，一般cookie无法容纳，所以存在localStorage中；每次请求需要携带这样的Header，有时甚至比body还大。







### 主动Token失效处理

#### 场景

- 退出登录
- 修改密码
- 修改用户权限
- 用户账户被删除/冻结
- 用户被注销

这些场景在session-cookie中可以由服务端删除session更新记录处理，而token认证中，当前token始终有效，信息无法更新。

#### 解决方案

- **将Token存在内存数据库**

  需要让token失效时，直接从Redis中删除token即可。

  缺点是每次请求都需要验证token，违背了无状态原则。

- **黑名单机制**

  类似上一个方案，维护一个内存数据库的黑名单，想要让token失效则将其放入黑名单中。每次请求校验token是否在黑名单。

- **修改密钥secret**

  为每个用户准备专属的secret，让用户的token失效则修改他的secret。

  相比之下危害更大：

  - 分布式环境下，密钥的修改需要多机器同步；同时密钥需要存在数据库或者其他服务，就跟session没什么区别了；
  - 一次修改，多端登录都会失效，可能不符合使用逻辑。比如网页登出导致手机端下线。

- **token的有效期设置比较短并经常轮换**
  简单，可以定期筛掉死用户；缺点是用户登录态不能长期维持，需要经常登录。



### Token续签处理

#### 场景

采用token短且经常轮换的策略时，用户需要频繁登录，但这个过程可以不借助用户手动登录，而是动态获取一个新Token的方式。

参考session，假设一次登录有效期30分钟，30分钟内有操作，则有效期延长30分钟。

#### 解决方案

- **参考session：临近过期更新Token**

  客户端访问服务端，如果发现快过期，则提前颁发新的Token给客户端。

- **每次请求都返回新的Token**

  简单，但是开销很大

- **Token有效期统一设到半夜**

  比较现实折中的方案，保证大部分用户在正常时间可以登录，适用于安全性要求不高的系统

- **登录接口返回两种Token：AccessToken与RefreshToken**

  - accessToken：过期时间较短，如30分钟
  - refreshToken：过期时间较长，如1天

  客户端登陆后，将两种token存在本地，每次访问传递accessToken，服务端进行校验。

  如果accessToken过期，则用refreshToken提供给服务端获取新的accessToken进行登录，如果refreshToken也过期则重新登录。

  不足是：

  - 客户端需要额外的配合
  - 用户注销需要同时失效两个token
  - 重新获取accessToken的一段时间内会存在无有效token可用的情况。（可通过客户端定时更新token实现）

#### 总结

Token适用于服务端不保存用户状态的场景，所以一旦出现这种希望在服务端控制用户状态的问题，没有特别好的方案，都是用各种方式给token加上状态可标识，就和session-cookie认证很类似了。



## 单点登录（Single Sign-on）

https://tsejx.github.io/blog/authentication/

https://www.mybj123.com/17234.html

单点登录又称SSO，指在多系统应用群中登录单个系统，便可在其他所有系统中得到授权而无需再次登录。

传统的 All-in-one 型应用的认证系统和业务系统集合在一起的，当用户认证通过时，将用户信息存入 Session 中。其他业务只需要从业务中通过对应会话身份凭证取到用户信息进行相关业务处理即可。

> 个人理解：大型系统包含多个子系统，避免重复登录，要实现多个子系统之间，一次登录可以互相访问。



### 同域名SSO

#### 概念

存在相同域名下的两个子系统，如系统 A `a.abc.com` 和系统 B `b.abc.com` 。

#### 流程

1. 用户访问系统A，如果没有登录，则跳转SSO认证中心提供的登录页进行登录。
2. 登录认证后，服务端存储用户信息到Session，为用户生成对应会话身份凭证添加到响应头`Set-Cookie`中，客户端接收后，将cookie存入该域名中。
3. 后续发送请求时，因为系统AB在同一域名下，都会带上存入的cookie，即可通过登录认证访问系统A和B。

> 实际便是使用Session-Cookie认证，不过登录页面是多系统共享的。



### 跨域SSO







## CAS



### 快速搭建本地CAS服务端

#### 基本步骤

这里选用的CAS版本为5.3.1 更高版本依赖与jdk超过8，暂时不适合个人使用

- 拉取官方CAS代码，切换5.3分支

  ```shell
  https://github.com/apereo/cas-overlay-template.git
  ```

- 进入目录，直接打包，会生成一个cas.war包在target目录下

  ```shell
  cd cas-overlay-template 
  build package
  ```

- 打包后部署tomcat

  - 直接部署的话就是将target目录下的cas目录拷贝到tomcat的webapps目录下，启动tomcat

  - 使用idea的话，如图配置，在不修改现有项目的代码的情况下

    <img src="https://img-blog.csdnimg.cn/e749137c4a0c437bb87c2caa7aea828c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZXJfS25pZ2h0,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 80%;" />

    

    ![img](https://img-blog.csdnimg.cn/aa59d954ec594c11a263b1810bef7357.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ29kZXJfS25pZ2h0,size_20,color_FFFFFF,t_70,g_se,x_16)

- 启动后访问http://localhost:8080/cas 端口可自行更改

  ![image-20220823134753457](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202208231347506.png)

#### 默认账号密码

修改target/cas目录下WEB-INF下的application.properties配置项，重新打包

```properties
# application.properties中存在配置项，默认即为  账号casuser 密码Mellon
cas.authn.accept.users=casuser::Mellon
```

#### 延长ST有效期

某些情况下认证ticket生成后的校验时间异常长（目前未知原因），而ST默认有效期10s，此时生成后再验证过期导致校验失败，经过查找application.properties配置项为

```properties
# 单位为s
cas.ticket.st.timeToKillInSeconds=10
```

#### 为本地CAS服务配置域名和https证书

校验需要对服务端https证书校验，本地模拟时需要进行同步配置。

##### 编辑本地hosts 

添加自定义域名映射，比如这里设置本地域名为test.sso.com

hosts文件位置：C:\Windows\System32\drivers\etc\hosts

```text
127.0.0.1 test.sso.com
```

##### 为tomcat申请https本地证书

这里参考tomcat笔记，利用jdk自带keytool工具，内容暂时不作解释 tomcat版本为9

- 生成证书，在指令当前目录生成一个文件.keystore，这里生成到tomcat目录/conf下

  ```shell
  keytool -genkeypair -alias ssoKey  -keyalg RSA -keysize 2048 -keypass 123456 -storepass 123456 -keyalg RSA  -validity 3650  -keystore ./.keystore   -dname "CN=test.sso.com,OU=pix,O=pix,L=ZZ,ST=HN,C=CN" -deststoretype pkcs12
  ```

- jdk安装证书，因为校验需要，这个证书要存放在运行cas客户端的jdk中

  ```shell
  keytool -export -file ./.keystore.crt -alias ssoKey -keystore ./.keystore -storepass 123456
  # 需要输入jdk密钥库密码 默认changeit  选择信任  这里alias可以与之前不一样 存进去会变成全小写
  keytool -import -alias sso -file ./.keystore.crt -keystore $env:JAVA_HOME\jre\lib\security\cacerts -storepass changeit
  ```

- 检查是否已安装

  ```shell
  keytool -list -keystore $env:JAVA_HOME\jre\lib\security\cacerts -storepass changeit|findstr sso 
  # 删除证书
  keytool -delete -alias sso -keystore $env:JAVA_HOME\jre\lib\security\cacerts -storepass changeit
  ```

  ![image-20220824235402898](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202208242354969.png)

- 配置证书到tomcat，进入tomcat目录下conf/server.xml  解开如下注释

  ```xml
  <Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
             maxThreads="150" SSLEnabled="true">
      <SSLHostConfig>
          <Certificate certificateKeystoreFile="conf/localhost-rsa.jks"
                       type="RSA" />
      </SSLHostConfig>
  </Connector>
  ```

  修改如下：

  ```xml
  <Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
             maxThreads="150" SSLEnabled="true">
      <SSLHostConfig>
          <Certificate certificateKeystoreFile="conf/.keystore"
                       certificateKeystorePassword="123456"
                       type="RSA" />
      </SSLHostConfig>
  </Connector>
  ```

- 此时启动的tomcat即可支持test.sso.com 的https请求，对应端口号8443

#### 默认不支持http认证：未认证授权的服务

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202208231358412.png)

本地测试客户端可能没有https证书又没必要配，可以配置支持http请求

同样是application.properties

```shell
#设置安全为false
cas.tgc.secure=false
#开启识别json文件，默认false
cas.serviceRegistry.initFromJson=true
 
# 配置允许登出后跳转到指定页面
cas.logout.followServiceRedirects=true
# 跳转到指定页面需要的参数名为 service
cas.logout.redirectParameter=service
```

然后修改WEB-INF\classes\services\HTTPSandIMAPS-10000001.json，为serviceId中的正则表达式添加http的或条件

```json
{
  "@class" : "org.apereo.cas.services.RegexRegisteredService",
  "serviceId" : "^(https|http|imaps)://.*",
  "name" : "HTTPS and IMAPS",
  "id" : 10000001,
  "description" : "This service definition authorizes all application urls that support HTTPS and IMAPS protocols.",
  "evaluationOrder" : 10000
}
```

#### 使用数据库查询用户

- 搭建用户数据库

  ```mysql
  -- 创建数据库表空间
  CREATE DATABASE test_cas DEFAULT CHARSET utf8 COLLATE utf8_general_ci;  
  USE test_cas;  
  -- 创建帐号信息表
  DROP TABLE IF EXISTS `cas_user_base`;  
  CREATE TABLE `cas_user_base` (  
    `id` INT(11) NOT NULL AUTO_INCREMENT,  
    `user_name` VARCHAR(45) DEFAULT NULL,  
    `user_psd` VARCHAR(45) DEFAULT NULL,  
    PRIMARY KEY (`id`)  
  );  
  -- 插入登录帐号数据
  INSERT INTO `cas_user_base` VALUES (1,'123','123'),(2,'admin','123456');
  ```

- **cas overlay添加数据库的JDBC插件，在pom.xml增加如下配置**

  ```xml
  <!-- Database Authentication Begin -->
  <dependency>
      <groupId>org.apereo.cas</groupId>
      <artifactId>cas-server-support-jdbc</artifactId>
      <version>${cas.version}</version>
  </dependency>
  <dependency>
     <groupId>org.apereo.cas</groupId>
     <artifactId>cas-server-support-jdbc-drivers</artifactId>
     <version>${cas.version}</version>
  </dependency>
  <!-- Database Authentication End -->
  ```

  这里因为用的是mysql，所以可以不导入cas-server-support-jdbc-drivers，而是直接导入mysql驱动

  ```xml
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.47</version>
  </dependency>
  ```

- **增加数据库连接配置**

  创建目录\casoverlay\cas-overlay-template\src\main\resources，新增文件application.properties，增加数据库配置

  ```properties
  cas.authn.jdbc.query[0].sql=SELECT * FROM cas_user_base WHERE user_name=?
  cas.authn.jdbc.query[0].url=jdbc:mysql://localhost:3306/test_cas?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&useSSL=false&serverTimezone=UTC
  cas.authn.jdbc.query[0].dialect=org.hibernate.dialect.MySQLDialect
  cas.authn.jdbc.query[0].user=root
  cas.authn.jdbc.query[0].password=
  cas.authn.jdbc.query[0].driverClass=com.mysql.jdbc.Driver
  cas.authn.jdbc.query[0].fieldPassword=user_psd
  ```

- 再重新打包部署即可

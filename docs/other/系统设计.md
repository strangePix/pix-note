# 系统架构设计

## 领域驱动设计

DDD（Domain-Driven Design 领域驱动设计）

开发团队和领域专家一起通过 通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域（核心子域，通用子域，支撑子域），并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。





## 微服务优化



### 共享库/微服务之间的代码共享问题

[参考](https://www.maguangguang.xyz/how-to-deal-with-shared-library)

很多项目都存在common.jar或者common.so等类似的共享库，这里进行一个分析。

#### 共享库的问题

举例说明，存在一个叫common的工程，几乎所有的微服务都要依赖它，目的是共享代码，减少重复。

这个工程会包含的内容：

- 基础架构相关：如权限控制、日志、Redis、消息队列等集成
- DTO
- 枚举
- 异常处理
- 工具类（如日期转换、价格计算等）
- 业务逻辑代码

这个库的问题在于**职责不单一**，承载过多内容，可能导致的后果：

**微服务不独立**

共享库使得微服务之间建立了隐藏的耦合关系。

- 当一个服务要对共享库进行升级时，很难确定对其他服务的影响，增加了微服务开发团队之间的沟通成本；
- 极端情况出现两个微服务通过共享库共享业务代码，模糊微服务边界，大而全的共享库破坏微服务的独立性。

**预期之外的引入**

当一个服务需要的一个功能依赖common库时，即使不需要其他功能，这个服务也会获得这个库里面所有的功能，这会产生一些我们不期望的后果。

- 比如当前工程存在于common库同名的工具类，添加代码时可能选择错误的依赖且没有发现，导致代码没有按照与其工作。

**版本冲突**

不同服务的需求不一样，随业务的变化，共享库的代码会不断更新。

- 如服务A与B都依赖于公共库common，版本号1.0。后来根据A服务的需求变化，更新了某工具类tool，common库版本更新为1.0.2。

  这时服务B要更新公共库更新其中的其他内容，比如枚举类，并且要使用原工具类tool，这时要更新common还需要基于A升级后的版本，就会产生版本冲突。

微服务较多时，大而全的共享库版本管理是比较困难的。



#### 如何在微服务间共享代码

根据上文中的共享库内容进行拆分，做不同的处理：

##### 职责单一的基础架构库

**适用范围**：功能稳定、通用，与业务无关的代码

推荐以职责单一的共享库形式存在。

如：日志、权限控制等分别以日志库和权限库存在，微服务按需添加。

##### 代码复制

**适用范围**：DTO、枚举、工具类、异常处理等

在不同微服务上下文不一定能完全复用，可以在不同微服务复制代码，再根据自身需求进行修改。

如：

- API上下游通信，上游接口DTO的10个字段，下游不一定需要那么多，则下游DTO定义不一定一致；
- 上游传递的枚举值，建议下游不要以枚举形式接收，而是以字符串形式，避免上游增加枚举种类导致下游报错。

##### 不共享业务逻辑代码

业务逻辑出现在共享代码意味着微服务边界不清楚，需要对微服务划分合理性和清晰度做出评判。





### 循环依赖问题（待补充）

[参考](https://www.maguangguang.xyz/eliminate-cyclic-dependency)

#### 熵增定律

> 任何孤立系统，在没有外力作用的情况下，其总混乱度（熵）会不断增大。

软件系统当然也不例外，随着软件系统的功能不断增加，系统的混乱度也在不断增大。

为了降低软件系统混乱的速度，必须要对其施以外力（重构）。

重构系统和重构代码一样，首先要先识别系统的坏味道，其中的一个坏味道便是循环依赖。



#### 循环依赖的危害

这里的循环依赖指微服务之间的循环依赖，类似于类之间的循环依赖，使得依赖关系形成一个环，有很多危害：

1. **微服务之间的耦合性很强，服务很难做到独立部署**

   这违反了微服务的初衷。

   这种情况往往是服务之间调用没有约束，为了方便取用/更新数据，服务之间随意调用，使得微服务的系统逐渐演变成**分布式大单体**。

   如图：

   ![循环依赖示例](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/8394116913_1182575.png)

2. **循环依赖可能导致循环调用或并发问题**，造成一些复杂难以定位的问题。

   以上图的订单-用户-客户依赖为例：

   - 订单服务依赖于客户服务获取客户信息，为了能够根据客户姓名查询订单，将客户id于客户姓名冗余在订单表。
   - 为了保证数据有效，在客户信息更新时，客户服务需要调用来更新订单上的客户信息。

   这时存在一个场景，订单状态变化时，客户状态需要变化，使得订单服务调用更新客户服务。

   同时因为客户信息变化需要反过来更新订单上的客户信息。

   如果订单上存在乐观锁，同一时刻的两次订单更新会有一个因乐观锁失败。

   在问题排查时会优先考虑并发问题，但实际上并不是。

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/8394116872_919558.png)



#### 导致循环依赖的原因

##### 数据过度冗余

数据冗余是服务间循环依赖的主要原因。

为了保证服务间数据一致性，某个服务数据修改需要同步到其他服务，保证其他服务冗余字段的信息准确。

**场景**：上述案例中订单表的客户姓名冗余字段。

冗余字段是增强了业务实现的简便性，但为了数据的一致性，增加了服务间不必要的调用。



##### 缺失业务概念

和数据过度冗余相对的是**在软件设计时缺少必要的业务概念**。

**场景**：上游系统的数据状态需要下游系统的数据进行计算得到，在核对上游的数据状态时，上游调用下游服务接口进行计算。

> 对应真实场景就是
>
> **如果一个客户的所有订单要么取消，要么已经完成开票结算流程，那么这个客户就是一个成功客户，否则是一个服务中客户**
>
> 如果软件设计时没有为客户定义一个状态标识成功/服务中的业务概念，那么每一次需要客户状态时都需要通过订单服务进行查询计算。



##### 滥用同步调用

上面两种场景一旦产生循环依赖，往往也伴随着同步调用的滥用（不绝对）。

**场景**：用户离职，更新客户的所有者信息。

用同步调用的方式从实现结果上来看是非常直接有效的方法，

但长远看，这种无脑的滥用同步调用让系统的复杂度变的非常高，当我们希望替换或重构某个服务，我们很难依据业务分析清楚到底有哪些服务会受到影响。



#### 消灭循环依赖的方法

目前不考虑微服务划分不合理的场景，循环依赖通常是**为了满足某种业务需求，在服务之间增加了不合理的调用**。

要解决循环依赖，必须要在微服务之间建立一些原则来**约束微服务之间的通信**，定期通过这些原则来审视我们的系统，找到问题并进行重构：

- **定义服务上下游关系**，下游服务可以直接依赖上游服务，反之则不可

- 上游服务的变更对下游服务产生影响需要**通过领域事件（异步）的方式**来实现

- 服务之间要通过数据Id（或类Id，能够唯一代表数据且不变的属性）来进行关联，尽量**不做过多的数据冗余**

- 一旦需要上游服务调用下游服务才能完成业务时，要**考虑上游服务是否缺少业务概念**

- 为满足前端逻辑而导致的服务间交互逻辑要放到BFF（Backend for frontend）中，而不是增加服务间的调用

  > BFF，即 Backend For Frontend（服务于前端的后端），也就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理，又称为用户体验适配器。
  >
  > BFF 只是一种逻辑分层，而非一种技术。
  >
  > https://www.jianshu.com/p/eb1875c62ad3
  >
  > https://www.maguangguang.xyz/backend-for-frontend



#### 排查循环依赖

我们可以通过一些技术手段来发现系统中的循环依赖问题：

- 通过链路追踪系统（如Zipkin）将服务间依赖关系可视化出来；
- 也可以在发现问题时将有问题的流程时序图画出来，可视化的方式可以很容易帮我们找到系统中循环依赖的问题。
- ...







## BFF治理与优化（待补充）

https://www.maguangguang.xyz/bff-governance
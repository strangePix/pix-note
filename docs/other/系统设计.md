# 系统设计

## 领域驱动设计

DDD（Domain-Driven Design 领域驱动设计）

开发团队和领域专家一起通过 通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域（核心子域，通用子域，支撑子域），并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。





## 微服务优化



### 共享库/微服务之间的代码共享问题

[参考](https://www.maguangguang.xyz/how-to-deal-with-shared-library)

很多项目都存在common.jar或者common.so等类似的共享库，这里进行一个分析。

#### 共享库的问题

举例说明，存在一个叫common的工程，几乎所有的微服务都要依赖它，目的是共享代码，减少重复。

这个工程会包含的内容：

- 基础架构相关：如权限控制、日志、Redis、消息队列等集成
- DTO
- 枚举
- 异常处理
- 工具类（如日期转换、价格计算等）
- 业务逻辑代码

这个库的问题在于**职责不单一**，承载过多内容，可能导致的后果：

**微服务不独立**

共享库使得微服务之间建立了隐藏的耦合关系。

- 当一个服务要对共享库进行升级时，很难确定对其他服务的影响，增加了微服务开发团队之间的沟通成本；
- 极端情况出现两个微服务通过共享库共享业务代码，模糊微服务边界，大而全的共享库破坏微服务的独立性。

**预期之外的引入**

当一个服务需要的一个功能依赖common库时，即使不需要其他功能，这个服务也会获得这个库里面所有的功能，这会产生一些我们不期望的后果。

- 比如当前工程存在于common库同名的工具类，添加代码时可能选择错误的依赖且没有发现，导致代码没有按照与其工作。

**版本冲突**

不同服务的需求不一样，随业务的变化，共享库的代码会不断更新。

- 如服务A与B都依赖于公共库common，版本号1.0。后来根据A服务的需求变化，更新了某工具类tool，common库版本更新为1.0.2。

  这时服务B要更新公共库更新其中的其他内容，比如枚举类，并且要使用原工具类tool，这时要更新common还需要基于A升级后的版本，就会产生版本冲突。

微服务较多时，大而全的共享库版本管理是比较困难的

#### 如何在微服务间共享代码

根据上文中的共享库内容进行拆分，做不同的处理：

##### 职责单一的基础架构库

**适用范围**：功能稳定、通用，与业务无关的代码

推荐以职责单一的共享库形式存在。

如：日志、权限控制等分别以日志库和权限库存在，微服务按需添加。

##### 代码复制

**适用范围**：DTO、枚举、工具类、异常处理等

在不同微服务上下文不一定能完全复用，可以在不同微服务复制代码，再根据自身需求进行修改。

如：

- API上下游通信，上游接口DTO的10个字段，下游不一定需要那么多，则下游DTO定义不一定一致；
- 上游传递的枚举值，建议下游不要以枚举形式接收，而是以字符串形式，避免上游增加枚举种类导致下游报错。

##### 不共享业务逻辑代码

业务逻辑出现在共享代码意味着微服务边界不清楚，需要对微服务划分合理性和清晰度做出评判。





### 循环依赖问题（待补充）

[参考](https://www.maguangguang.xyz/eliminate-cyclic-dependency)


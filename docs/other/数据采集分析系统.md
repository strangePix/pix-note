## 数据分析模型

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209021655089.jpeg)

**用户行为伴随产生的大量数据**；

通过“金字塔”模型处理，将**用户的行为数据转化为关键维度指标或者用户行为规则**，这些数据后续会成为项目活动、迭代的客观依据支撑。



## 术语



### 数据采集

通过各种**触点**，针对**特定的用户行为**进行**捕捉**及**发送**的过程。

- 触点：直接或间接地、传递出目标信息的**实体、服务或环境**，这里指客户端/服务端/第三方数据平台。
- 捕捉：即埋点。



### 埋点

在数据采集领域指的是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。

一般通过客户端或服务端SDK采集、或者异步导入的形式，按照数据应用的要求，上报数据。通过埋点完成数据采集，将数据存入事件表-用户表模型。



### 维度

描述的是一个事物身上所具备的特征或属性。在用户行为分析系统当中，维度就是事件属性和用户属性，往往用来描述和分析指标。

如“城市”就是一种维度，包括北京、上海、深圳、广州等；如“操作系统”包括ios、android；“渠道”包括app store、华为应用市场、小米应用商店等。



### 指标 

是量化的数值 **。** 

包括UV、PV、人均次数、时长、点击率、渗透率、留存率、成功率等。

指标可分为计数指标和复合指标：

- 计数指标：如访客、访问、页面浏览量、停留时长等；
- 复合指标：如跳出率、交互深度、转化率等。



### 访客（Visitor）

访问网站或 App 的人。

加上 Unique 后，即我们平常说的 UV，唯一身份访客。

一般用匿名 ID 来标记访问者，网页端产品是 Cookie（网站服务器投放在用户浏览器上的一小段文本），App 端产品是设备 ID。



### 访问（Visit）/会话（session）

指用户在一定时间段内一系列连续的页面浏览行为，跟会话 Session 同义。可以包含多个页面、元素事件。

随着移动互联网的崛起，考虑到 App 的使用，Session 慢慢代替 Visit 成为主要用词。

 业界对于 Session 内行为间的间隔设定了有效期限，网页端产品为 30 分钟，App 端产品时间较短，一般为 1 分钟。



### 页面浏览量（PV）

PageView，指页面被用户浏览的次数，

严格定义上指的是用户向网站发出并完成的一个下载页面的请求。

页面浏览的概念主要适用于网页端产品，对于 App 的分析，现主要使用**屏幕浏览**，即 ScreenView。



### 活跃用户数（UV）

访问的不重复用户数，同一访客只会被计算一次。



### 注册用户数



### 新用户数

历史上首次访问的独立访客定义为新用户。



### 留存用户

用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用该应用的用户，被认作是留存用户。

这部分用户占当时新增用户的比例即是留存率。



### 停留时长

对应于用户 Session，主要用来衡量用户与网站、App 交互的深度。交互越深，相应停留的时长也越长。 

一般有页面停留时长，会话时长以及平均停留时长等概念，其计算的核心原理在于记录下用户行为发生时的时间戳，后期再应用相应公式来计算。



### 交互深度

指用户在一次浏览网站或 App 过程中，访问了多少页面。用户在一次浏览中访问的页面越多，交互深度就越深。

交互深度能够侧面反映网站或 App 对于用户的吸引力。 

可以通过 Session 来计算用户的平均交互深度。



### 预置属性

事件、用户、物体需要配置自定义属性进行分析。为了方便使用者使用，会为起提供预置属性，用于基础统计和无配置使用。





## 数据采集项目流程

[参考](https://www.volcengine.com/docs/6285/108780)

1. 数据需求规划

   - 如何梳理需求文档：[如何梳理需求](https://www.volcengine.com/docs/6285/108781)
   - 行业指标体系模板：[分行业指标体系](https://www.volcengine.com/docs/6285/108788)

2. 数据采集方案设计

   - 如何设计数据埋点采集方案：[如何设计埋点采集方案](https://www.volcengine.com/docs/6285/110093)
   - 分行业埋点方案模板：[分行业埋点方案模板](https://www.volcengine.com/docs/6285/67136)

3. 埋点实施

   - 数据接入：[数据接入指引](https://www.volcengine.com/docs/6285/66833)

4. 埋点测试

   - 实时埋点检测：[实时埋点检测](https://www.volcengine.com/docs/6285/66054)
   - 数据校验：[数据校验](https://www.volcengine.com/docs/6285/108784)

5. 正式环境上线

6. 基础配置

   详细查看基本配置文档：[基础配置](https://www.volcengine.com/docs/6285/108785)

7. 使用

   产品功能使用文档可查看：[使用指南](https://www.volcengine.com/docs/6285/100043)





## 埋点分类

### 代码埋点

- 优点：
  - 准确度高：可以精准控制触发条件，什么时候才触发，准确统计某一事件；
  - 自定义强：可以自定义很多丰富的数据数据传递到；
- 缺点：
  - 工作量大：需要跟踪的地方都添加对应的跟踪代码，需要埋点，因此工作量会比较大；

#### 客户端埋点

**原理**

部署完基础的SDK/JS后，在需要采集数据地方添加跟踪代码，启动的时候会初始化SDK/JS。

你点击或触发数据采集位置的时候就会调用SDK/JS对应的数据接口把数据发送出去，例如，我们要对某个位置的点击做埋点，也就是该按钮被点击的，这个按钮对应的OnClick就会调用SDK/JS提供的数据接口去发送数据。

通常来说，为了避免消耗用户的流量，一般是多条数据压缩后发送，而不是一条就发一次。

**问题及处理**

- 工作量：提供代码管理工具/埋点管理平台；
- 性能影响：在大部分的第三方都不是实时发送的，都是累计压缩数据后，等网络比较好的时候才发送数据的；现在的手机，处理能力可能都不亚于一些旧的台式电脑的。
- 数据传输的不可靠：只要涉及到网络，都可能会有网络延迟或丢包出现的，是通病来的，也有很多解决方案，加锁，重发，回调；
- 准确度：Web能够达到99.9%，至于那1%是因为用户屏蔽了cookie导致的数据对不上，这个是有方法可以解决的，APP是100%。

#### 服务端埋点

**方式**

- **通过协议的形式将数据直接发送给收集数据的服务区**

  如Google Analytics的MP协议、神策直接发送数据的 Consumer；

  这种方式将服务端看做是一个终端，就类似一个客户端触发的时候就向收集数据的服务器发送数据，如果客户端会丢数据，那么服务端埋点的也会丢，两者是一样的原理的。

  > Measurement Protocol简称MP协议，中文名是测量协议。https://zhuanlan.zhihu.com/p/86411804
  >
  > 是一套规则，只要应用遵循规则就可以向GA服务器发送原始数据。按照测量协议的规则格式化HTTP请求，这种格式化的HTTP请求就叫做测量协议请求。

- **最常用的日志**

  如日志做很多个性化的定制实现数据的采集；

  这个工作量就大了，代码复杂，对于一个用户量比较多的产品，而且做比较多配置，埋点跟踪的话，日志的增长速度是非常快，

  日志的存储和删除会是个很大的问题，而且通常自己的BI和各种系统都会将日志的相关数据入库，有点重叠的意思。

#### 前后端差异

- 服务端埋点不会出现匹配不到的情况，个别需要服务端返回状态的，没有返回给客户端，那么客户端就跟踪不到，往往需要服务端才行。

  如成功提交表单，成功发表文章这些.

  > 但其实只要服务端返回状态，前端也是可以跟踪到的，如服务端用数据层或MP协议去跟踪，而且是一定准确的。

- 国内的工具很强调服务端的的方式采集数据，强调客户端会出现统计的不准，和自己的业务数据库数据对不上，出现丢数据的情况，这是前端数据采集的先天缺陷，因为网络异常，或者统计口径不一致，都会导致数据对不上。

- 国外的工具倾向通过客户端埋点，因为国外的工具往往都会提供TMS（Tag Manager System，代码管理工具），自定义功能非常强，可以通过TMS控制条件触发与数据发送，可以很精准的实现数据采集，这样的管理其实很方便的。

  > **Tag Manager System(TMS)**
  >
  > 标签管理系统，用于管理第三方的跟踪代码和数据标准化传输。如Google Tag Manager。
  >
  > 通过GTM可以快速创建，嵌入和更新跟踪代码，从而获得数据标准化和部署速度的好处。

- 国内虽然有厂家提供TMS，但还没有达到能够随意控制数据传输，所以代码埋点往往会变得很复杂，不能脱离开发直接实现跟踪。

  试想一下，如果是增加某个埋点，有TMS的，直接加完就发布出去，没有TMS，需要开发在页面或服务端加代码后，服务器去update才生效。

### 可视化（无码）埋点

开发者无需再对追踪点进行埋码，而是脱离代码，只需面对应用界面圈圈点点即可追加随时生效的事件数据点。

- 优点：
  - 部署简单：能大大节省人力成本；
  - 便于运营产品配置：不同代码的产品和运营，可以通过可视化界面进行配置；
- 缺点：
  - 不灵活：不能自定义获取数据属性，部分可视化的位置可能覆盖不全；
  - 每次启动加载服务端最新的配置资源，浪费客户端流量；
  - 每次页面的结构变化，都会使选择失效，需要重新圈选才可以，工作量较大；

**流程**
当APP启动的时候从服务端更新配置和资源，APP根据新的配置和资源上报数据，整个结构有点类似GTM的，配置都是在GTM，

用户每次打开加载到的是最新的GTM配置，那么GTM上部署的触发条件有可能被触发，从而实现数据收集。

> **GTM**
> Google 代码管理器，根据各个数据收集数据工具（GA ,Firebase）模版而进行触发事件的代码。

**原理**

web和APP的页面都有类似的结构，在部署完SDK后，SDK会自动获取页面各个层级的关系。

在web是dom结构，在APP是UIVIEws，当你用可视化页面设置埋点的时候，服务器能够自动知道元素的位置，并且将这些配置保存到服务器，

用户打开的时候，就会加载这些配置到客户端，当用户触发该元素的位置时候，就会将相关数据发送出去。



### 自动/全/无/无痕埋点

不需要埋点，已经尽可能的收集所有控件的数据。

- 优点：
  - 部署简单，数据自动收集：只需部署SDK，初始化几行代码，就会自动收集数据；
  - 自动收集很多数据，能够回溯；
- 缺点：
  - 不灵活：不灵活自定义数据属性；
  - 网络传输压力：收集的数据多，给网络传输带来压力，消耗用户的流量和电量，部分会涉及隐私问题；

**原理**
SDK利用CSS选择器技术和监听控件的事件触发技术，在APP中嵌入SDK，这个SDK就会将APP中尽可能多的操作都采集下来，可以通过可视化操作界面对采集的数据做分类，基本上是先收集，后筛选的节奏，可能会出现数据噪音的情况。

**与可视化埋点的对比**

- 对信息的采集和处理流程不一样：
  - 可视化埋点是采集的才处理；
  - 而无埋点是先采集所有的，再选择性处理。
- 无埋点采集的是尽可能多的数据，所以无埋点能够对数据做回溯，但是这也意味浪费流量，浪费电，坑用户，头部APP不会用这种方式；
- 可视化埋点和无埋点是噱头远大于实际，在国内众多的增长工具中，虽然都提供了所有的埋点方式，但是代码埋点才是最常用的一种方式，在实际的应用中长出现跟踪不到，跟踪不准确等问题，绝对是不靠谱的。



## 埋点模型



### PV模型

- 基于PV/UV统计页面/按钮的使用情况
- 无法实现深度用户行为分析（新老用户行为差异、转化率、行为路径等）
- 无法精细化用户行为粒度数据



### 事件模型

事件模型包含**事件(Event)**和**用户(User)**两个核心实体。



#### 五要素

- **Who人物**

  参与事件的用户是谁。

  需要标识ID对用户进行唯一区分：

  - 未登录用户：cookie、设备ID等匿名ID
  - 已登录用户：后台实际分配的用户ID

  对用户的姓名、手机号、身份证号码等敏感信息不建议直接采集，如必须采集可采用脱敏的方式进行。

- **When时间**

  事件发生的实际时间。

  常见标准的YYYY-MM-DD HH-MM-SS的时间戳以外还可以使用服务端的Session或登录序号等。

  记录值将用于区分用户的登陆次数，界定活跃次数和行为归属。

- **Where地点**

  事件发生的地点。

  省份、地市、特殊的如用户的IP地址、GPS位置、场景或来源（WEB/微信/APP）。

- **How方式**

  用户从事事件所处环境和方式。

  如 网络环境（WIFI/4G）、系统版本（iOS 12.0.1/Android 8.0)、设备型号（HUAWEI/XIAOMI/Apple）

  浏览器、APP版本、操作系统、进入渠道、跳转的上级页面等。

- **What行为**

  描述用户做了什么。

  完整的用户行为，如“购买”事件就包含从商品信息到订单信息等。



#### 参考模型：事件

记录用户行为或过程。

- **事件类型**

  - 预设事件：自动采集事件，如启动/退出等
  - 非预设事件：基于业务需求

- **事件名称**

  准确描述事件的中文字段，有时用**事件类别**代替；

- **事件类别/事件行为（GA）**

  用户的行为，如：

  - 点击事件：点击按钮触发一次，不论点击结果；
  - 浏览事件：一次进入（打开/刷新）算一次，会存在浏览时长；

- **事件ID**

  事件唯一标识；

- **事件描述**

  对事件进行业务阐述；

- **事件备注**

  描述埋点操作的数据，如何时新增、修改、删除、原因、操作人等。保证可追溯性；

- **记录规则**

  定义什么情况下触发埋点，如：在列表页点击一次记录一次

- **事件标签（GA）**

  事件发生的定位，如在哪个页面，播放的哪个视频；

- **事件值（GA）**

  行为衍生的数值。如浏览时长，视频播放时长；

- **是否交互类型（GA）**

  交互类型的事件会纳入跳出率的计算，一般将事件都设置为非交互的类型的；











### 参考分析模型文档

- **GrowingIO**：https://docs.growingio.com/v3/introduction/datamodel/

- **诸葛IO**：https://docs.zhugeio.com/datamanager/data_model.html

- **神策**：https://manual.sensorsdata.cn/sa/latest/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1573771.html

  https://manual.sensorsdata.cn/sa/latest/%E5%88%86%E6%9E%90%E6%A8%A1%E5%9D%97-1573429.html

- 字节-增长分析：https://www.volcengine.com/docs/6285/81354



### GrowingIO

用户模型-事件模型-统计模型

#### 用户模型

分为访问用户与登录用户：

##### 访问用户

分析产品访客，以终端生成唯一ID，进行渠道、转化等相关的分析。

- **访问用户 ID**：每一个访问应用的用户都会在对应的设备中生成并记录一个唯一的 ID。

- **用户属性**：不要求强制登陆，但也需要用户维度进行行为分析。

  - 微信小程序：微信用户属性如性别

  - 基于匿名用户的 A/B 测试标签

    > **A/B测试**
    >
    > https://leovan.me/cn/2021/10/abtest-you-should-know/
    >
    > 一种产品优化的方法，为同一个优化目标制定两个方案（比如两个页面），让一部分用户使用 A 方案，同时另一部分用户使用 B 方案，统计并对比不同方案的转化率、点击量、留存率等指标，以判断不同方案的优劣并进行决策。

**访问用户的区分**

- Web：根据cookie
- App：根据用户唯一ID区分访问用户

  - Android用户唯一ID：Android ID或IMEI

  - iOS用户唯一ID：IDFV或IDFA
- 小程序：
  - 默认按照cookie判断访问用户；
  - 如果不取关小程序，则cookie不会发生变化；
  - 当设置forceLogin后，则会默认按照openid来判断访问用户，且不采用365天的限制。

##### 登录用户

分析注册用户，以注册生成唯一ID，进行跨平台分析和更高级的业务分析。

- **登录用户 ID**：当前用户在业务系统中唯一的身份ID。

- **用户属性**：与登录用户ID一并上传系统用于分析。

  - 业务系统中用户的一些基本信息和分类
  - 业务系统中已经明确的用户标签

  不适合：

  - 频繁变化的用户状态：如用户当前位置、用户累计在线时长等
  - 枚举值非常多的用户属性：如用户手机号、用户mac地址、用户注册时间等



#### 事件模型

通过事件记录用户行为。



##### 事件的产生

1. SDK通过客户端监听等手段**捕获**用户行为；
2. SDK将用户行为**转化**为事件消息，发送服务器。



##### 事件的组成

- **用户信息**：描述用户的信息，如用户ID，用户类型（访问/登录）
- **时间信息**：事件发生的时间
- **行为信息**：用户做了什么行为
- **行为对象信息**：用户行为的作用对象，如页面，文本框，按钮等。



##### 事件采集类型

根据采集方式的不同区别：

###### 无埋点事件

用户无需额外开发任何代码，通过集成 SDK ，自动采集生成的事件‌。

- 页面事件：进入页面触发
- 访问事件：产生一个新的访问
- 激活事件：APP首次激活打开
- 唤醒事件
- 点击事件
- 曝光事件：元素展现时
- 输入事件

###### 埋点事件

用户通过开发额外代码，调用SDK提供的埋点事件API，主动向服务器发送事件。



##### 无埋点事件

通过在网页、App和小程序中加载 SDK 来实时捕获用户行为并将之转化为无埋点事件

###### 分类/层级关系

按照用户行为层级关系进行分类：访问-页面-动作

直接举例理解：

- 09:50:13 【访问事件】用户小明使用自己的 iPhone 8 手机打开了App

  - 09:50:14 【页面事件】小明看到了App的开屏页面

  - 09:50:16 【页面事件】小明看到了App的首页
    - 09:50:18 【动作事件】小明点击了页面上的注册按钮

  - 09:50:20 【页面事件】小明看到了App的注册页
    - 09:50:21 【动作事件】小明填写了页面上的手机号
    - 09:50:24 【动作事件】小明填写了页面上的验证按钮
    - 09:50:28 【动作事件】小明填写了页面上的验证码
    - 09:50:30 【动作事件】小明点击了页面上的注册按钮

  - 09:50:20 【页面事件】小明看到了App的首页

###### 访问事件

访问事件代表：

- Web端：用户在一定时间内首次打开网站页面
- 移动端：用户在一定时间内首次打开移动应用
- 小程序：用户在微信中打开小程序

一次访问会生成一个 session 值，各平台的 session 刷新时间如下：

- Web端：首次访问时生成 session，当用户30分钟内无操作行为，之后有操作行为，刷新 session。
- 移动端：冷启动时生成 session，当App进入后台30秒后再次启动，刷新session。
- 小程序：冷启动时生成 session，当小程序进入后台5分钟后再次启动，刷新session。

包含的信息属性：

- 用户设备信息
- 用户位置信息
- 用户访问应用信息
- 用户落地页信息

###### 页面事件

页面事件代表：

- Web平台：用户通过浏览器访问了一个页面
- 移动平台：用户在移动应用中访问了一个页面
- 小程序平台：用户在微信中访问了小程序的一个页面

包含的信息属性：

- 域名/包名
- 页面
- 查询
- 页面来源

###### 行为/元素事件

行为事件代表：

- Web：点击/浏览/提交表单/修改输入框
- 移动端：点击/浏览控件
- 小程序：点击/提交表单/修改输入框

包含的信息属性：

- 页面信息：域名/包名/页面/查询
- 动作的目标元素信息：元素/路径/列表位置/内容

##### 埋点事件

###### 分类/层级关系

作为无埋点事件的补充，层级关系同无埋点的行为/元素事件

###### 埋点方式

- 客户端埋点：调用SDK的API发送埋点事件
- 服务端埋点：应对复杂的业务事件，如客户端没有成功标识节点，数据录入的数据分析。

#### 统计模型

##### 指标-事件的度量

###### 含义

指对GrowingIO采集到的事件的度量，一个事件会形成多个指标。

> 如一次登录用户浏览首页事件，可用到：1. 首页浏览量 2. 首页浏览访问用户量 3. 首页浏览登录用户量 三个指标

###### 类型

- 预定义指标：内置，宏观指标。如访问量、浏览量
- 无埋点指标：指定页面/元素产生的指标。如注册按钮点击量
- 埋点指标：用户发送埋点事件产生的指标。如订单金额

##### 维度-事件的属性

###### 含义

在分析统计中，用于分解、过滤以及对比指标的角度。

> 以一个浏览器维度举例：
>
> 2018年8月1日，GrowingIO网站首页浏览量为6497次
>
> - 使用**浏览器维度**对这个指标进行**分解**，看到：
>   - Chrome浏览器的浏览量为3543次
>   - IE浏览器的浏览量为1321次
> - 我们也可以使用浏览器维度做**过滤条件**，只查看满足 浏览器=Chrome 条件的浏览量为：3543次

###### 分类

事件包含的属性就是维度的来源。

- 访问级维度
- 页面级维度
- 动作级维度
  - 无埋点事件维度
  - 埋点事件维度

###### 维度继承

维度本身具有层级关系，高级别的维度可以用于分解低级别事件定义的指标。



### 诸葛IO

#### 会话（session）

##### 概念

用户在一次产品使用中，从开始到结束的过程，用户在互动的过程中会发生一次或多次会话，并且每个会话都会产生一个或多个的事件。

##### 判定

- 从「打开产品」到「关闭产品」视为一次会话；
- **iOS**：屏熄、home键切到后台、杀掉进程即判断为会话结束；
- **Android**：当应用重新进入活跃状态与上次活跃状态相隔30秒以上时，会计为一次新的会话；
- **web、小程序**：会话的开始是用户打开产品的某个页面，如果用户在30分钟内没有任何操作或关闭页面，则会话结束；

##### 技术

技术上，通过cookies(小程序通过storage)追踪用户的会话。

##### 会话时长计算

用同一次访问内触发的最后一个事件的时间减去会话开始的时间。如果用户没有事件触发，那么时长就是1s。

#### 事件

用户在产品中的每一个操作行为都可以定义为一个事件，每一个事件会带有属性信息。

##### 定义

- **事件**：用户在产品上的行为。如进入首页/点击登录/登录成功
- **属性**：描述事件的维度，如手机号
- **值**：属性的内容，如18888888888
- **采集时机**：首页加载完成/点击登录按钮/服务返回登录成功

另外默认采集环境属性：事件产生时间/设备信息/版本信息/ip/地域/浏览器信息等。

##### 埋点方式

支持前/后端埋点，其他都是废话。

- 前端埋点优势在于很多事件的触发和后端没有交互，在前端埋点可以更加清晰用户的行为流，了解用户的使用情况；
- 后端埋点方式更加准确，同时避免了数据延迟上传的问题；
- 同时将前端没有的业务信息通过后端埋点的方式上传，完善用户的属性信息，结合其他事件，更深入的了解数据；

##### 事件分组

将众多的行为事件分门别类进行组织的一种方式，方便对事件进行分门别类地管理和使用。

##### 重要事件

从产品业务角度将重要的用户行为标注出来，方便分析和使用。



#### 用户

用户是分析的最小单元

##### 用户属性

- **全局唯一的名称/ID**：一般是在用户注册时确定，并且用户来登录的，通过这个id可以区分每个用户的身份；
- **一组描述用户特点的属性/属性值**

##### identify

使用identify记录用户的属性（如性别、年龄等），通过给不同用户分配不同的id来识别用户，调用identify方法即可上传数据。

- 采集：通过identify上传的id来识别用户，当一个用户触发identify后就会和设备绑定，之前的用户行为都会归为这个实名用户。
- 集成：调用identify方法就可以，推荐在能获取用户信息的位置调用方法，如用户的登录\注册或者进入个人中心页会刷新个人信息的时候调用。
- identify不需要每个页面都调用，在有另一个id上传之前，所有用户行为会归为这个id。
- 用途：调用identify方法后，认为用户是一个实名用户，并且具有上传的用户属性，可以在【用户】模块中按照用户属性进行筛选用户，并且保存用户分组。
- 没有的情况：将其当做匿名用户，并分配一个匿名id，直到该用户进行了identify时，会将之前**匿名**状态时的行为都归为这个用户。
- 同一用户多次identify：修改唯一标识会视为多个用户；同一标识只保留最新版本信息。

##### 用户识别

每个设备都会记录三个id，设备id、设备上的用户id、诸葛id，并提供了用户设备关系表。

- userID：用户id，触发identify时，用户自定义上传的标识。（唯一）
- device_id：设备id，每个用户使用产品时都会自动生成。
- zg_id：诸葛id，每个用户使用产品时自动生成。（唯一）

> 注：唯一指的是和其他用户不会重复。一个userID和zg_id只会在一个用户上

**登录前后的用户唯一识别**

- 新设备，登陆前访问应用，会生成匿名用户；
- 设备由用户注册/登录，则将之前的匿名用户与该用户关联。

**一个用户多个设备（跨设备）**

一个实名用户多台设备的访问数据会记录在一个用户下。

换设备登录时，设备信息改变。

**一个设备多个用户（多开）**

只有调用identify的方法，无法做退出登录的判断。

- 第一个用户退出后，第二个用户登录前，行为数据记录在第一个用户；
- 第二个用户登陆后，行为数据记录在第二个用户。

##### 实名/匿名用户

- 匿名用户(没有调用identity方法)：
  - 通过设备id来计算；
  - JS通过cookie判断，清除了cookie或者使用隐身窗口打开，会识别为新的用户；
  - Android通过设备序列号、品牌信息、制造商、CPU架构、设备类型等设备信息判断，删除/重新下载APP，有一定概率会识别为新的用户；
  - iOS通过IDFA或IDFV判断，删除/重新下载APP，不会识别为新的用户。
- 实名用户：通过userID做判断。

##### 用户画像

- 用户属性
- 用户行为序列
- 用户使用频次



### 神策

#### 概述

括事件（Event）和用户（User）两个核心实体，同时配合物品（Item）实体可以做各种维度分析。

#### Event（事件）

##### 五要素

- Who：用户标识，使用 distinct_id 来设置用户的唯一 ID

  - 未登录用户：可以是 cookie_id、设备 ID 等匿名 ID
  - 登录用户：建议使用后台分配的实际用户 ID

  提供了 track_signup 接口，将同一个用户注册之前的匿名 ID 和注册之后的实际 ID 贯通。

- When：事件发生的实际时间。

  - 使用 time 字段来记录精确到毫秒的事件发生时间
  - 不主动设置，则会自动获取当前时间作为 time 字段的取值

- Where：事件发生的地点。

  - 可以设置 properties 中的 $ip 属性，这样系统会自动根据 ip 来解析相应的省份和城市
  - 根据应用的 GPS 定位结果，或者其他方式手动设置$city 和 $province

- How：从事这个事件的方式。

  包括用户使用的设备、使用的浏览器、使用的 App 版本、操作系统版本、进入的渠道、跳转过来时的 referer 等。

- What：描述用户所做的这个事件的具体内容。

  - 使用 event 这个事件名称，来对用户所做的内容做初步的分类
  - 没有太多预置字段，根据每个产品以及每个事件的实际情况和分析的需求，来进行具体的设置

##### 收集

神策建议后端记录

- 很多字段在前端（App 和 Web 界面）是拿不到的，甚至前端没有相应功能；
- 后端修改更方便，APP每次需要发版和用户更新；
- APP收集有丢失风险，数据不及时。

**除非某个行为只在前端发生，对后端没有任何请求，否则建议永远只在后端收集数据**。

##### 不可变

出于性能和可解释性等各方面的考虑，Event 是被设计为不可变的。

因为 Event 代表的是历史上已经发生过的事件，一般来说不应该需要进行更新。

#### User（用户）

##### 概述

- 每个 User 实体对应一个真实的用户，用 distinct_id 进行标识，描述用户的长期属性（也即 Profile）
- 该用户可与其所从事的行为，也即 Event 进行关联
- 记录 User Profile 的场所，是用户进行注册、完善个人资料、修改个人资料等几种有限的场合

##### 字段记录在Event与User的抉择

- Profile 记录的是**用户特征的属性**，例如：出生地、性别、注册地、首次广告来源类型等。
- Event 的字段，记录的是**事件发生时的特征**，字段的取值具有场景性，例如 省份、城市 、设备型号、是否登录状态等。
- 对于 Profile 字段，一般来说为了降低维护成本，更偏向于用一些固定不变字段，如 “年龄” 和 “出生日期”会选择出生日期。

##### 用户标识

使用 神策 ID (即 events 表里的 user_id 和 users 表里的 id )来对每个产品的用户进行唯一的标识，而 神策 ID 是基于 distinct_id 按照一定规则生成的。

**设备ID**

- Android：之前默认使用 UUID，卸载重装 UUID 会变；可以通过配置使用 AndroidId。
- IOS：优先使用 IDFV，获取失败，则使用随机的 UUID；可以通过配置使用 IDFA，能避免用户在重装 App 后设备 ID 发生变化的情况。
- JS：默认情况下使用 cookie_id，规则为五段不同含义的字段拼接而成来保证唯一性，其中包括两段时间戳，一段屏幕宽高，一段随机数，一段 UA 值。
- 小程序：默认情况下使用 UUID，建议获取并使用 openid；有一个暂存操作。

> 设备 ID 并不一定是设备的唯一标识。例如 Web 端的 Cookies 有可能被清空（例如各种安全卫士），而 iOS 端的 IDFV 在不同厂商的 App 间是不同的。
>
> 神策的客户端 SDK 已经做了各种处理。

**登录ID**

- 通常是业务数据库里的主键或其它唯一标识；
- 会存在 users 表里的 second_id 字段；
- 未注册登录时没有登录ID；
- 一旦确定尽量不要修改；
- 用户是发生事件的主体，不一定是终端用户，也可以是一个企业、商家甚至是一辆汽车。

##### 接入方案

方案不兼容。

- 只用设备ID；
- 设备ID和登录ID一对一；
- 设备ID和登录ID多对一；



#### Item（实体）

作为事件的补充：

- Event 实体中一些基本信息中会有许多是不断变化的
- 埋点采集中，发现某些 Event 在最初的阶段采集到的数据不完善。

所谓 Item，在严格意义上是指一个和用户行为相关联的实体，可能是一个商品、一个视频剧集、一部小说等等。

**属性**

- item_type：区分不同的 item 类型，比如 movie、muisic 等；
- item_id：区分同一个 item 类型下面的不同的 Item；
- 自定义属性



### 火山引擎（字节）

#### 事件+用户模型

- **事件**： 用户在访问网站、APP、小程序、公众号等触点时会发生一系列的行为交互；

- **事件属性**：在事件触发时，可以采集到事件发生的形式、位置等，用来描述事件的信息，称为事件属性；

  > 还是4W1H，何人、何时、何地、通过何种方式、发生了何种行为。

- **用户**：事件行为的发生主体人；

- **用户属性**：

  - 和行为无关的用户自身状态的属性，例如年龄、性别等。
  - 和行为有关，但不变或者不经常变化的属性，例如注册时间、VIP等级、最近一次支付时间等。

- 事件表和用户表通过火山引擎为每一个用户生成唯一的SSID，进行关联。

#### 虚拟事件

对一个或者多个**原始事件**通过一定逻辑关系，进行拆解和组合，组合成虚拟事件，便于用户对于常规复合事件的组合管理、查看。

> 原始事件：通过SDK上报或者导入数据产生的事件。

#### 用户标识

使用 device_id、user_unique_id、ssid 三种 id 标识设备和用户。

- **device_id/web_id**：设备的唯一标识。

  - 通过设备注册服务根据获取到的设备信息为每个设备生成唯一的标识，该标识会通过客户端sdk在设备本地进行存储；
  - 另，网页端、小程序使用web_id，作用与 device_id 基本相同；

- **user_unique_id**：用户唯一标识。

  - 一般情况直接使用产品业务中使用的用户标识，比如登录账号;

  - 当 user_unique_id 未设定时，在SaaS版本中，系统会自动使用 device_id/web_id 替代，在私有化版本中，会显示为空；

- **ssid**：火山引擎增长分析为用户/设备自动分配的唯一标识。

  与 device_id/web_id、user_unique_id 相关联，以实现对匿名和实名状态用户的统一标识。

##### SSID

1. 贯通一个用户在一个设备上注册（登录）前后的行为，同时不会因为登录行为被重复记作新增用户；
2. 打通一个注册用户在不同设备上登录之后的行为；
3. 解决同一设备多个账户登录的各用户行为归属问题。

##### 匿名与实名识别

设备ID相同的情况下，当用户进行了注册登录，我会给该用户分配与其未登录匿名时相同的 SSID，这样就可以确保用户登录前后的行为归属于同一人。

##### 新老用户识别

提供了一个虚拟用户属性“user_is_new”，使用时会判断用户属性中保存的第一条事件发生日期和分析时所选定时间的中某一天是否为同一天来判断用户在该日是否为新用户。

导入数据时，需要调用 set_profile 接口将首事件时间更新一次。



#### session

##### 概念

即会话，用户自开始访问，到结束访问会进行一系列的行为交互，如点击按钮交互、浏览页面交互等，这一系列的行为交互便构成了一个会话。

一个人可以产生多次会话，会话的结束依据切割时间而定。

![image.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209051152569.png)

##### 切割时间

两个事件触发时可以接受的最长时间间隔。

超过间隔的两个事件会被划分到不同的session，即两个行为事件间隔超过切割时间，则视为一个新的会话开始。



#### 被动事件与关系事件

基于「用户」的主动触发和被动受影响的行为描述。在一些业务场景中，用户既有可能是行为的发起者，也有可能是行为的影响者。

- 主动事件：行为发起者触发产生的行为

- 被动事件：行为影响着所有影响的行为

- 关系事件：主动事件与被动事件存在对应关系，成对出现时称为关系事件。

  > 如社交软件中发生了A关注B：
  >
  > - 主动事件：用户A关注了用户B
  > - 被动事件：用户B被用户A关注

**主被动基于"用户"**

主动触发行为的不是用户，则不能视为主动事件；被动行为影响的不是用户，则不能视为被动事件。

> 系统给用户推送通知，程序触发了给用户发送了消息：只有被动事件，因为主动触发行为的不是用户。





## 埋点的坑

埋点的核心不是越多越好。很多时候要求埋点文档越细致，很可能坑越多，**不一致导致的问题在实际应用中比漏埋点造成的坏处大得多**。

- 埋点整改一般跟随发版，版本迭代后埋点同步一致性。
- 没有埋点管理平台，或者跨部门的埋点公示没做好，影响客户端数据。
- 埋点管理人员更迭，交接导致的问题。
- 埋点字段不是越多越好。
- **埋点重要信息缺失**：埋点管理人员更迭，交接导致的问题；文档不完整，沟通不一致。
- **埋点数据不足**：设计不完善，分析时才发现缺失细分信息。
- **埋点口径不统一**：业务数据与分析数据不一致
- **埋点浪费**：有些历史埋点无人查询，导致环境中事件堆积越来越多。





## 分析模型

### 基于事件的数据分析模型

- **事件分析**

  事件的统计指标、属性分组、条件筛选等查询分析。

- **漏斗分析**
  分析一个事件从起点到终点各阶段的用户转化率。

- **留存分析**

  分析用户参与情况、活跃程度、后期留存。

- **分布分析**

  - 分析某个事件的用户分布情况；
  - 展现用户对产品的依赖程度；分析用户不同条件的行为数据。

- **归因分析**

  通过事件来源分析有价值的渠道/方式。

- **用户路径分析**

  分析用户在使用产品时的路径分布情况。

- **网页热力分析**

  点击分析，分析用户在网页的点击、触达深度等情况。

- **用户分群分析**

  用户信息标签化管理。

- **间隔分析**

  分析转化时长分布，进而分析业务。

- **属性分析**

  根据用户属性进行分类和统计。

### 基于用户的分析模型

- **来源分析**
- **留存分析**
- **用户画像**



## 分析指标







## 技术参考

- 采集
- 清洗
- 存储
- 计算
- 可视化
- 分析



### 小象分析

https://gitee.com/xiaoxiangopen/analysis

- 终端SDK采集数据通过JSON 以 HTTP POST方式提交到服务端API
- 服务端通过nginx接收API数据，写入日志文件，实现高可靠高扩展
- Flume实时读取nginx日志，进行解密和日志格式处理
- 处理结果明文数据发布存放kafka
- Flink消费
- 埋点数据存入HDFS
- ClickHouse（？）
- Redis
- MySQL

![输入图片说明](https://images.gitee.com/uploads/images/2021/0427/092847_e6c637d8_5325125.png)

### 诸葛

- 存储引擎：Kudu HDFS

- 工作流引擎？

- 消息中心：Kafka Redis

  > 包含以下业务消息的汇集和分发：
  >
  > - 各种SDK或者工具上传的数；
  > - 数据清洗产生的中间的数据；
  > - 模型结果数据；
  > - 备份数据；
  > - 其他流式处理数据；

- 消费

  > - 进行元数据统计管理
  > - 进行备份
  > - 进入数据仓库模型前的清洗
  > - 进行实时的统计计算;

- 业务存储：MySQL ES

- 缓存：Redis SSDB Codis

  > - Codis是分布式的Redis实现框架，用来做分布式的消息以及状态存储
  > - SSDB是基于Redis协议的硬盘实现，存储一些键值比较大或者多的数据，例如实时数据以及数据缓存。

- 实时计算中心：Spark Streaming

- 数据收集：LVS负载均衡+Nginx+Lua

  > 虽然Nginx的性能很高，但是在高并发压力情况下，我们能够快速添加Nginx节点，再加上数据采集是异步，所以大流量情况下，LVS+Nginx基本上都能保证不会出现连接等待的情况了。
  >
  > Lua是一种轻型的脚本语言，直接在nginx配置中嵌入，在很多游戏的服务端架构以及电商秒杀的架构中使用。服务端接收到上传数据之后，Lua会进行解析，并且添加上传时一些信息（ip，服务端时间，User-Agent）等等，然后push到Kafka的集群。

- HTTPS加密传输，以及支持HTTP2协议

  > - 采用HTTPS的原因是，防止数据在传输过程中被抓包截获；
  > - 采用HTTP2协议，服务端的处理性能能够极大的提升，连接也有优化。

![preview](https://pic2.zhimg.com/v2-4f1e95e29bcf9db87c55d25f6cec9b25_r.jpg)

![image-20220907111857837](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209071118860.png)



### Growing IO

- 日志采集：loki
- 对象存储：FTP on HDFS
- 消息：kafka
- 实时数据处理：Flink
- 离线数据处理：Spark
- 文件数据存储：HDFS
- 数据仓库：Clickhouse
- 其他：
  - 微服务 gRPC
  - 任务调度 spring scheduler akka
  - 反向代理 openresty
  - 服务监控 prometheus

![image-20220907112543033](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202209071125099.png)



### 神策

https://www.zhihu.com/question/35993792/answer/65402818

- 大数据基础组件：
  - HDFS
  - KUDU
  - SKV
  - Yarn
  - Flink
  - Spark
  - Impala



### 补充参考技术

- [Logan-大前端日志系统（美团开源）](https://github.com/Meituan-Dianping/Logan/blob/master/README-zh.md)

  前端日志系统，支持多端运行，提供前端日志的存储、收集、上报及分析能力。

- [Apache Druid 高性能的实时分析型数据库](http://www.apache-druid.cn/)

  支持实时摄取、高性能查询和高稳定运行的应用场景，同时，Druid也通常被用来助力分析型应用的图形化界面，或者当做需要快速聚合的高并发后端API，Druid最适合应用于面向事件类型的数据。





### 总结

每一项技术不能为了用而用，需要集合场景、性能。别人不用不代表我就不用，别人用不代表我就适合。

目前总结的需求应该是

- 私有化部署，初版应该是单机
- 安全性未知，但应该不低
- 数据量按照亿级别估算，不能只用MySQL，但不一定要用大数据
- 将来可能会部署多套的可能
- 因为不算对外产品，很多定制化东西应该可以固定

然后再总结技术栈





## 具体模型



### 用户







## 功能

### 现有功能

#### 网站



### 扩充功能



## 解决方案（补充）

### 私有化部署

https://xie.infoq.cn/article/f2fe62b274e9edf985ecc221b



### 如何通过嵌入一段代码记录用户页面点击行为

前端考虑



### 如何唯一标识一个访客，IP和访客的区别



### 如何定位省份、城市



### 来源页面、离开页面、来源关键词、来源广告



### 如何确定用户离开



### 基于事件的设计



### 数据安全



### 数据清洗

对数据进行一些处理，过滤无用的信息，规范得到能用到的数据。包括但不限于以下情况：

- 过滤SPAM垃圾数据，例如被攻击/造假/BUG产生的大量数据

- 抽取有用字段，例如上传的数据包含的信息很多，只用到一小部分

- 原始数据有很多格式不规范，要统一格式

**需要处理的问题**

- 垃圾数据：乱码或者埋点错误产生的数据
- 作弊数据：恶意进行注入伪造的数据
- 淘汰数据 ： 已经弃用的SDK版本数据



### 数据加工

数据加工是指清洗后的数据，还需要补充一些信息，可能是通过数据库查询出来的，也可能是通过计算规则计算出来的，或者算法技术加工出来的新字段。

例如，数据里面有个ip地址，需要计算出用户的地理位置，那么地理位置就是加工出来的字段。

一般来讲，对于大多数大数据分析平台而言，加工是很重要的过程，基本上最后可用来进行分析的数据，要通过这一步充分完成加工计算。

- 识别用户和设备的身份关系
- 加工字段：地理位置、UTM推广信息、设备、系统版本（网站或者微站根据UA）
- 事件行为匹配系统id



### 数据加载

数据加载是指把加工后的数据加载到合适的存储，可能是Hadoop集群的HDFS上，也可能是某个数据库，有可能是文件等等其他存储类型。

**诸葛**

1. 原始数据备份：

   - AWS S3

   - HDFS（私有部署）

2. 加工后的数据：

   - AWS S3

   - HDFS（私有部署）

3. 模型数据仓库

   - Redshift

   - Greenplum（私有部署）

> S3和HDFS都是文件访问。
>
> S3是因为存储成本低，HDFS是大多数企业的Hadoop平台。
>
> Redshift和Greenplum都是基于PostgreSQL的。





# 产品


# 蘑菇博客搭建记录

选用开源项目[蘑菇博客](https://gitee.com/moxi159753/mogu_blog_v2)



## 安装启动

这里使用的是Docker(Nacos)版本

### 拉取Docker镜像

```shell
docker pull moxi/mogu_blog_nacos
```

### 制作容器

```shell
docker run --privileged -d -it -h mogu_blog_2 --name mogu_blog_2 -v /etc/localtime:/etc/localtime:ro -p 11122:22 -p 15672:15672 -p 8600:8600 -p 9527:9527 -p 9528:9528 -p 6379:6379 -p 3306:3306 -p 80:80 -p 8080:8080 -p 8601:8601 -p 8602:8602 -p 8603:8603 -p 8604:8604 -p 8605:8605 -p 8606:8606 -p 8607:8607 -p 5601:5601 -p 9411:9411 -p 465:465 -p 8848:8848 -p 8070:8070 moxi/mogu_blog_nacos /usr/sbin/init
```

注意制作容器前要让出对应端口号，以及开放防火墙

```yaml
蘑菇Docker内部容器SSH连接: 11122
RabbitMQ消息队列: 15672
Zipkin链路追踪: 9411
发Email端口: 465   
图片资源: 8600   
前端Web页面: 9527    
后端Admin页面: 9528  
Redis: 6379   
Mysql: 3306   
Tomcat(里面部署的solr): 8080
HTTP端口: 80
Kibana端口: 5601
mogu_admin端口: 8601
mogu_picture端口: 8602
mogu_web端口: 8603
mogu_sms端口: 8604
mogu_search端口: 8605
mogu_monitor端口: 8606
mogu_gateway端口: 8607
nacos端口: 8848
sentinel端口: 8070
```

### 通过SSH访问容器内部

端口号11122，账号root 密码mogu2018

```shell
# docker指令也可以 不过这样比较方便后续操作
docker exec -it mogu_blog_2 bash
```

### 启动nginx

```shell
# 创建需要的目录
mkdir -p /var/run/nginx
# 启动nginx
/soft/nginx/sbin/nginx
# 添加nginx到环境变量
vim /etc/profile.d/path.sh
export PATH=$PATH:/soft/nginx/sbin
source /etc/profile
# 之后启动可以直接执行
nginx
```

> 每次重启容器都会丢失/var/run/nginx文件夹，导致启动失败
>
> 可以通过修改配置文件，固定nginx.pid文件位置
>
> ```shell
> vim /soft/nginx/conf/nginx.conf
> # 打开上方的配置
> pid        logs/nginx.pid;
> # 保存文件 创建目录
> mkdir -p /soft/nginx/logs
> # 重新启动，可以看到生成了文件 /soft/nginx/logs/nginx.pid
> ```

观察已启动程序端口

```shell
netstat -tunlp
```

![image-20220411172229364](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220411172229364.png)

已经开机自启了 RabbitMQ的 5672 15672 ， mysql的 3306， 其他的一些就是项目的端口，现在我们还需要启动 redis的 6379 和 tomcat的 8080

### 启动RabbitMQ

如果RabbitMQ没有启动，则启动

```shell
# 后台启动RabbitMQ
rabbitmq-server -detached
```

### 启动Redis

```shell
/soft/redis/bin/redis-server  /soft/redis/bin/redis.conf
# 添加到环境变量
vim /etc/profile.d/path.sh
export PATH=$PATH:/soft/redis/bin
source /etc/profile
# 指令
redis-server  /soft/redis/bin/redis.conf
```

### 启动tomcat中的solr（可选）

```shell
还没做
```

### 启动Nacos

Nacos是由SpringCloudAlibaba开发的服务注册和配置中心

```shell
cd /soft/nacos/bin
./startup.sh -m standalone
# 观察日志确认启动成功与否
cat /soft/nacos/logs/start.out
```

启动成功后访问http://your_ip:8848/nacos  默认账号密码nacos nacos

![image-20200903161619843](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/6b5028c5baeb43bdbc27f01bfcd302bb.jpg)

### 启动Sentinel（可选）

Sentinel是用来做服务的熔断、雪崩、限流，相当于原来的Hystrix

```shell
cd /soft/sentinel
# 启动Sentinel
./startup.sh
# 查看日志
cat catalina.out
```

启动成功后访问http://your_ip:8070 默认账号密码sentinel sentinel

![image-20200903162631281](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1486759c1c194743a0ba47d556e431d8.jpg)

### 启动微服务

```shell
#进入到项目目录
cd /home/mogu_blog
```

项目目录

![image-20200903163514966](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/6d1ce7fe90ab45068da2995227176da0.jpg)

```yaml
mogu_admin: admin端API接口服务
mogu_data: 存在蘑菇博客的图片资源
mogu_monitor: 服务监控
mogu_picture: 图片服务器，用于图片上传和下载
mogu_sms: 消息发送服务器，用于邮件和短信发送
mogu_web: web端API接口服务
mogu_zipkin: 链路追踪模块
vue_mogu_admin: VUE的后台管理页面
vue_mogu_web: VUE的门户网站
```

#### 启动mogu_admin

```shell
cd /home/mogu_blog/mogu_admin
./startup.sh	# 启动脚本
./shutdown.sh	# 关闭脚本
cat catalina.out # 查看日志
```

#### mogu_web配置

进入nocos配置，修改mogu_web_prod.yaml文件

改为自己的ip地址/域名

```yaml
data:
  # 门户页面
  webSite:
    url: http://***:9527/#/
    # 有域名可以改成如下
    # url: http://www.moguit.cn/#/
    
  # mogu_web网址，用于第三方登录回调
  web:
    url: http://***:8603
```

修改第三方注册需要的 clientId 和 ClientSecret

```yaml
# 第三方登录
justAuth:
  clientId:
    gitee: XXXXXXXXXXXXXXXXXXXXXX
    github: XXXXXXXXXXXXXXXXXXXXXX
  clientSecret:
    gitee: XXXXXXXXXXXXXXXXXXXXXX
    github: XXXXXXXXXXXXXXXXXXXXXX
```

##### clientId和clientSecret获取

需要到各自的码云和github设置上进行获取：在码云中：我们首先进入设置页面，然后选择第三方应用，然后创建应用

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1577774049160.png)

然后开始填写对应的内容

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1577774070401.png)

重新点击第三方应用，获取到对应的ClientID和Client Secret替换即可

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1577774097799.png)

Github上的操作同理，我们需要设置setting，然后选择Developer settings，OAuth Apps：创建一个新的

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1577774134599.png)

这里填写的信息和刚刚码云上差不多，最后一个 Authorization callback URL需要改成github的回调地址

格式：http://127.0.0.1:8603/oauth/callback/github

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1577774162993.png)

然后最后在创建成功后复制对应的ClientID和Client Secret即可：

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1577774183497.png)

QQ的在这里申请https://connect.qq.com/manage.html#/appcreate/web 

需要备案 之后再做。

#### 启动mogu_web

```shell
cd /home/mogu_blog/mogu_web
# 启动项目
./startup.sh
```

#### mogu_sms配置

进入nocos配置，修改mogu_sms_prod.yaml文件

修改邮箱的配置，我们将发送邮件的信息改成自己的

```yaml
#mail
mail:
    username: XXXXXXX@163.com
    password: XXXXXXX #授权码开启SMTP服务里设置
```

##### 获取SMTP授权码

以163邮箱为例，我们需要开启SMTP服务，然后设置授权码

![image-20200722090457339](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/c1f29c98397442c385cfb151ae5a76fc.jpg)

#### 启动mogu_sms

```shell
cd /home/mogu_blog/mogu_sms
# 启动项目
./startup.sh
```

#### 启动mogu_picture

```shell
cd /home/mogu_blog/mogu_picture
# 启动项目
./startup.sh
```

#### 启动mogu_gateway

```shell
cd /home/mogu_blog/mogu_gateway
# 启动项目
./startup.sh
```

#### 验证是否后台是否启动成功

访问nocos后台-服务管理-服务列表-prod，应该有5个服务

![image-20220411215909870](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220411215909870.png)

访问swagger接口

http://your_ip:8601/swagger-ui/index.html 

http://your_ip:8603/swagger-ui/index.html

### 修改前端配置

让前端请求的是部署的后端接口

#### 修改vue_mogu_admin配置

```shell
cd /home/mogu_blog/vue_mogu_admin/dist
# 编辑index.html
vim index.html
# 文件是被压缩 可以通过编辑器处理
# 替换配置 其中前端页面地址BLOG_WEB_URL可以用域名替换
"BLOG_WEB_URL":"http://120.78.126.96:9527"
```

```html
<script id=env>
window._env_ = {"NODE_ENV":"production","ADMIN_API":"http://120.78.126.96:8607/mogu-admin","PICTURE_API":"http://120.78.126.96:8607/mogu-picture","WEB_API":"http://120.78.126.96:8607/mogu-web","Search_API":"http://120.78.126.96:8607/mogu-search","Spider_API":"http://120.78.126.96:8607/mogu-spider","FILE_API":"http://120.78.126.96:8600/","BLOG_WEB_URL":"http://demoweb.moguit.cn","SOLR_API":"http://120.78.126.96:8080/solr","ELASTIC_SEARCH":"120.78.126.96:5601"};
</script>
```

#### 修改vue_mogu_web配置

```shell
cd /home/mogu_blog/vue_mogu_web/dist
# 编辑index.html
vim index.html
```

替换方式同上

### 搭建完成

访问http://your_ip:9527/nacos

配置域名的话，需要在nginx修改端口映射

###  项目中初始用户和密码

- **后台登录**：用户：admin，密码：mogu2018
- **前台登录**：用户：mogu2018，密码：mogu2018
- **Mysql**：用户：root，密码：mogu2018
- **Redis**：密码：mogu2018
- **远程SSH初始密码**：用户：root，密码：mogu2018
- **RabbitMQ管理页面：** 用户：admin，密码：mogu2018
- **Nacos管理页面：** 用户：nacos，密码：nacos
- **Sentinel管理页面：** 用户：sentinel，密码：sentinel
- **蘑菇博客监控页面**：用户：user，密码：password123
- **Druid初始密码：** 用户：admin，密码：123456





## 部署改动/配置







### 增加虚拟内存

8G内存依然容易宕机，外加配置了其他服务，所以学习配置虚拟内存

#### 创建Swap分区

- 查看磁盘使用情况

  ```shell
  free -h 
  ```

  ![image-20220414180013731](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220414180013731.png)

- 使用dd命令创建名为swapfile 的swap交换文件

  目录随意，这里设为/var/swapfile

  ```shell
  dd  if=/dev/zero  of=/var/swapfile  bs=1024  count=4194304 
  ```

  > dev/zero是Linux的一种特殊字符设备(输入设备)，可以用来创建一个指定长度用于初始化的空文件，如临时交换文件，该设备无穷尽地提供0，可以提供任何你需要的数目。
  >
  > bs=1024  ：单位数据块（block）同时读入/输出的块字节大小为1024  个字节即1KB，bs(即block size)。
  >
  > count = 4194304 表示的是4G
  >
  > 具体计算公式为：1KB * 4194304 =1KB *1024(k)*1024*4 = 4194304 =4G
  >
  > 如果小伙伴需要调整交换区的大小的话，可以自行设置其他的
  >
  > 执行完命令后，会进行4G读写操作，所以会有一些卡顿，小伙伴耐心等待 

- 将交换文件格式化为swap分区

  ```shell
  mkswap  /var/swapfile
  ```

- 挂载并激活分区

  ```shell
  swapon   /var/swapfile
  ```

  > 执行以上命令可能会出现：“不安全的权限 0644，建议使用 0600”类似提示，不要紧张，实际上已经激活了，可以忽略提示，也可以听从系统的建议修改下权限：
  >
  > ```shell
  > chmod -R 0600 /var/swapfile
  > ```

- 再次查看新分区是否添加并激活使用

  ![image-20220414181757212](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220414181757212.png)

- 修改 fstab 配置，设置开机自动挂载该分区

  ```shell
  echo  "/var/swapfile   swap  swap  defaults  0  0" >>  /etc/fstab
  ```

- 查看是否已经使用了交换内存

  ```shell
  top
  ```

  ![image-20220414182018641](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220414182018641.png)

  已经开始使用



#### 更改Swap配置

开启交换虚拟内存空间后，默认好像是当内存使用百分50的时候，就会开始使用交换空间，这样就会造成一个情况，就是本身物理内存还没有使用完成， 就去使用虚拟内存，这样肯定会影响我们的使用效率，需要避免这种情况。

方式是：

通过swappiness值进行管理，swappiness表示系统对Swap分区的依赖程度，范围是0~100，数值越大，依赖程度越高，也就是越高越会使用Swap分区。

这里设置10~50即可。

- 查看当前的swappiness数值

  ```shell
  cat /proc/sys/vm/swappiness
  ```

- 临时修改swappiness值

  ```shell
  sysctl vm.swappiness=10
  ```

- 永久修改swappiness值

  ```shell
  vim /etc/sysctl.conf
  # 修改 vm.swappiness = 0
  vm.swappiness = 10
  ```

- top查看分配情况

  物理内存使用率应该会控制在90%左右



#### 删除Swap分区

仅用于以后删除分区时候使用，虚拟内存不需要

- 停止正在使用swap分区

  ```shell
  swapoff  /var/swapfile
  ```

- 删除分区文件

  ```shell
  rm -rf   /var/swapfile
  ```

-  删除或注释掉我们之前在fstab文件里追加的开机自动挂载配置内容

  ```shell
  vim    /etc/fstab
  
  #把下面内容删除
  /var/swapfile   swap  swap  defaults  0  0
  ```



### 配置域名解析

申请到域名后，可以用域名的方式访问博客，而不止ip地址。

查看容器中的nginx配置

```shell
cat /soft/nginx/conf/nginx.conf
```

可以得知如下几个端口映射

```yaml
80: 映射nacospicture.moguit.cn 对应目录/home/mogu_blog/mogu_data/ 存储静态文件图片
8600: 映射localhost 对应目录/home/mogu_blog/mogu_data/ 存储静态文件图片
9527: 映射localhost 博客前台前端vue_mogu_web
9528: 映射localhost 博客后台前端vue_mogu_admin
443: 映射apipicture.moguit.cn 代理http://127.0.0.1:8602 mogu_picture端口
443: 映射apiweb.moguit.cn 代理http://127.0.0.1:8603 mogu_web端口
```

本来用个人的域名映射了ip，但这样不能用默认端口访问前台页面，而且不同服务的端口直接暴露在外部不太安全

#### 阿里云配置域名解析

首先搜索域名，进入后，点击解析

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1578025441424.png)

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1578025464834.png)

配置二级域名

```yaml
# 前台首页
www.moguit.cn
# 后台首页
admin.moguit.cn
# 图片域名
image.moguit.cn
```

添加后如图所示

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1578025502760.png)

#### 修改nginx配置

利用nginx反向代理，根据不同域名转发到对应服务器/目录

```shell
vim /soft/nginx/conf/nginx.conf
```

```nginx
server {
        listen       80;
        server_name  www.***.cn;
        location / { 
                root   /home/mogu_blog/vue_mogu_web/dist;
                index  index.html index.htm;
        }       
    }           
        
    server {
        listen       80;
        server_name  admin.***.cn;
        location / {
                root   /home/mogu_blog/vue_mogu_admin/dist;
                index  index.html index.htm;
        }
    }


    server {
        listen       80;
        server_name  picture.***.cn;
        location / {
                root   /home/mogu_blog/mogu_data/;
                index  index.html index.htm;
        }
    }
```

```shell
# 配置更新
nginx -s reload
```

效果就是  同样是80端口，来自不同server_name的请求会被解析到不同的目录。

#### 配置网站备案号

有域名的网站备案的话，要求将备案号挂在网站下 https://help.aliyun.com/document_detail/146190.html?spm=a2cmq.17629970.0.0.f0d079fef3oQKt

博客这边已经将备案号配置在网页中，不过用的是蘑菇博客的。所以只需要修改数据库的数据，在mogu_blog库的t_web_config表的record_num字段



### 配置网关

上面的域名解析只处理了静态的前端网页与图片服务，而后端接口依然是带有端口号，单独的微服务可以直接访问的，这样不方便管理，结合新配置的gateway网关服务，配置解析进行管理。

#### 配置网关域名解析

之前的网关访问地址为http://ip:8607/?/

在域名解析添加gateway.xxx.com解析：

![image-20220413160157011](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220413160157011.png)

#### 配置容器nginx端口映射

将http://gateway.xxx.com/映射到http://ip:8607/

```shell
vim /soft/nginx/conf/nginx.conf
```

```nginx
server {
        listen 80;
        server_name gateway.xxx.cn;
        location / {
            proxy_pass http://127.0.0.1:8607;
        }
    }
```

#### 修改前端配置映射

包括web和admin项目的.env文件，把之前配置的http://ip:8607/替换为http://gateway.xxx.com/

```properties
NODE_ENV=production
ADMIN_API=http://gateway.xxx.cn/mogu-admin
PICTURE_API=http://gateway.xxx.cn/mogu-picture
WEB_API=http://gateway.xxx.cn/mogu-web
Search_API=http://gateway.xxx.cn/mogu-search
Spider_API=http://gateway.xxx.cn/mogu-spider
FILE_API=http://picture.xxx.cn/
BLOG_WEB_URL=http://www.strangest.cn
```

重新部署即可。



### 配置防盗链

项目部署才一天就被人爬了一遍，用后端接口重新搭了个网站，还占用我的带宽，这能忍？

#### 图片配置防盗链

##### 阿里云配置

![image-20220412174040590](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412174040590.png)

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412174129229.png" alt="image-20220412174129229" style="zoom: 67%;" />

#### 后端接口防盗链

```shell
vim /soft/nginx/conf/nginx.conf
```

示例

```nginx
server {
    listen   80     ;
    server_name  www.mogu.com;
    # 必须使用域名访问
    if ($host != 'www.mogu.com') {
            return 403 ;
    }
    # 拦截非法referer
    valid_referers none blocked *.mogu.com;
    if ($invalid_referer) {
        return 403 ;
    }
    charset utf-8;
    location / {
        …………
    ｝
｝
```

##### valid_referers 指令

- 语法: valid_referers none | blocked | server_names | string … ;

- 配置段: server, location

- 指定合法的来源'referer', 他决定了内置变量$invalid_referer的值，这里并不区分大小写.

- 参数说明：

  - none “Referer” 为空

  - blocked “Referer”不为空，但是里面的值被代理或者防火墙删除了，这些值都不以http://或者https://开头，而是“Referer: XXXXXXX”这种形式

  - server_names “Referer”来源头部包含当前的server_names（当前域名）

  - arbitrary string 任意字符串,定义服务器名或者可选的URI前缀.主机名可以使用*开头或者结尾，在检测来源头部这个过程中，来源域名中的主机端口将会被忽略掉

  - regular expression 正则表达式,~表示排除https://或http://开头的字符串.

#### 使用网关，关闭微服务端口直接开放

开启网关微服务，请求直接走www.???.com/gateway/接口



### 更新项目同步到容器

因为从docker拉的镜像不代表是最新的项目，所以需要继续拉取分支更新，也是为了之后个人修改

#### 查看当前分支

这里是本地开发时进行查看，非部署环境

```shell
# 导入项目后查看当前分支
git branch
# 如果不是就切换分支
git checkout Nacos
```

![image-20201110090336834](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/afc55fcb348744c58390b20083e904b8.jpg)

选用的是nacos就没问题。

#### 导入新的数据库脚本

从代码中打开doc文件夹

```yaml
mogu_blog.sql: 代表mogu_blog数据库的文件
mogu_blog_update.sql: 代表mogu_blog在后续开发时候更新的字段）
mogu_picture.sql: 代表mogu_picture数据库文件
mogu_picture_update.sql: 代表mogu_picture在后续开发时候更新的字段）
nacos_config.sql: 表示Nacos配置脚本（仅用于Nacos分支）
```

首次导入，没有已经建立的数据库，则执行mogu_blog.sql，mogu_picture.sql和nacos_config.sql

如果已经部署使用，则参考mogu_blog_update.sql和mogu_picture_update.sql进行选择性的表的更新

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/0065b6c10d584aca9dfc31472a2d2d12.jpg)

> 若导入数据库时，出现下面的错误:
>
> ```shell
> Error Code: 1071 - Specified key was too long; max key length is 767 bytes
> ```
>
> 需要打开数据库配置，然后输入下面命令进行解决
>
> ```mysql
> show variables like '%innodb_large_prefix%';//查看是否开启
> set global innodb_large_prefix=on;//如果没有开启设置开启
> show variables like '%innodb_file_format%';//查看file格式
> set global innodb_file_format=Barracuda;//设置格式
> set global innodb_file_format_max=Barracuda;//设置格式
> ```



#### SpringBoot更新

进入mogu_blog_v2目录，进行打包

```powershell
cd mogu_blog_v2
mvn clean install
```

将对应模块的包，拷贝到docker容器的/home/mogu_blog对应模块的目录

执行停止脚本shutdown.sh和启动脚本startup.sh

如果修改了诸如Nacos的配置，还需要修改对应模块的config/bootstrap.yml文件，这个不在Nacos配置管理内。



#### Vue打包

##### vue_mogu_web打包

进入vue_mogu_web目录，修改.env文件

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/16cc81bc69004ec5bbe738a63ba0fc89.jpg)

修改其中的ip地址为自身的

VUE_MOGU_WEB可以配置域名映射

```shell
VUE_MOGU_WEB=http://www.moguit.cn
```

更新依赖并打包

```shell
# 安装依赖
npm install --registry=https://registry.npm.taobao.org
# 打包
npm run build
```

打包文件夹dist压缩为dist.zip放置在容器的 /home/mogu_blog/vue_mogu_web目录

>  注意：如果该文件夹下存在 dist文件夹，我们需要将其删除，然后在解压，然后使用下面命令进行解压
>
> ```shell
> unzip dist.zip
> ```
>
> 原因应该是nginx的相关配置

##### vue_mogu_admin项目打包

同理进入vue_mogu_admin目录

修改.env配置文件为自身ip，其中BLOG_WEB_URL可修改为前台域名

更新依赖并打包

```shell
# 安装依赖
npm install --registry=https://registry.npm.taobao.org
# 打包
npm run build
```

打包文件夹dist压缩为dist.zip放置在容器的 /home/mogu_blog/vue_mogu_admin目录，并解压

#### 访问效果

```shell
# 前台项目
http://yourIp:9527
http://www.moguit.cn
# 后台项目 admin  mogu2018
http://yourIp:9528
http://admin.moguit.cn
```



### 修改Nacos登录账号

[参考](https://nacos.io/zh-cn/docs/console-guide.html)

Nacos目前部署在线上时端口暴露，在关闭之前最好修改一下账号密码

- 生成加密密码， 利用如下代码将 nacos 改成你要改成的密码，运行即可得到加密有算法。注意盐值是随机的，所以生成密码每次可能不一样，请不要担心。

  ```java
  public static void main(String[] args) {
      	//	BCryptPasswordEncoder来自spring-security
          System.out.println(new BCryptPasswordEncoder().encode("nacos"));
  }
  ```

- 打开Nacos配置的数据库，如nacos_config，然后用获得的新密码修改或者添加账号

  ![image-20220412195224958](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412195224958.png)

- 同步修改所有服务bootstrap.yml里nacos的登录配置

  ```yml
  spring:
    cloud:
      nacos:
        username: nacos
        password: nacos
  ```

  > 如果是新账号有一个问题，线上部署Nacos采用了权限认证，非*ROLE_ADMIN* 角色的账号是无法通过的，而这个角色目前只能由一个账号持有，所以先修改密码或者不在公网开放吧。https://www.liujiajia.me/2021/7/28/nacos-enable-auth
  >
  > 本地部署/无权限认证没有这个问题

- 当然也可以通过图形化界面修改

  ![image-20220412233602598](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412233602598.png)

  ![image-20220412233542251](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412233542251.png)

  > 线上修改成功，本地通过图形界面修改密码失败，提示
  >
  > ![image-20220412233905621](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412233905621.png)
  >
  > [这个是个bug](https://github.com/alibaba/nacos/issues/7750)，前端发出的请求参数多拼了一个username导致用户名识别错误 
  >
  > ![image-20220412234343314](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412234343314.png)
  >
  > 回退至1.4.1版本或者等更新，当然不是很重要可以不管先用数据库修改

- 线上部署bootstrap.yml在每个微服务的config目录中，注意修改

  ![image-20220413032907285](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220413032907285.png)



### 限制IP访问

4.23更新：因个人网络动态IP定期更新无法设为固定值，目前的方式是尽量减少端口开放，通过nginx代理。

#### 修改Mysql限制IP访问

因为是个人调试项目，所以数据库端口暴露在公网，使用的又是root账号，风险比较大，所以进行一定程度的限制。

- 查看数据库，可以看到除了本地（localhost/127.0.0.1/::1），还开放了%允许所有ip访问

  ![image-20220413154027207](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220413154027207.png)

- 修改mysql密码，将Host为'%'的改为个人ip地址，密码酌情修改，目前默认是mogu2018

  ```mysql
  use mysql;
  update user set password=password('mogu2018'),Host='myIp' where Host='%' and User='root';
  ```



#### 修改Redis限制IP访问

以前就有过Redis被人攻破导致系统崩溃的事情，redis常规是部署在内网不公开端口，目前个人项目公开端口方便调试，但需要限制一下IP。即**配置redis外网可访问,并只允许指定的ip可访问redis**

##### 修改redis配置文件

```shell
vim /soft/redis/bin/redis.conf
# 修改这一部分配置 这里可以用ifconfig的inet配置在这里
bind 127.0.0.1
# 重启redis
```

但经过查询，修改配置文件的bind指定是Redis所在服务器网卡的ip，不是指定某些IP可以访问本机Redis实例，所以没有用。如果只指定127.0.0.1就是所有外网不能访问，如果指定了ifconfig的inet网卡地址又会变成所有外网可访问。

所以在保留redis本身可外网访问的前提下，通过防火墙/nginx代理限制特定ip访问即可，改redis配置行不通。

> 其他redis安全设置：redis进程不使用root权限用户启动等 [参考](https://www.cnblogs.com/zhoujie/p/redis2.html)

#### **云安全组端口IP限制**

因为使用云服务器，之前开放了特定端口才能直接访问对应服务，这时进入安全组对开放端口的授权对象从0.0.0.0改为特定ip地址即可。

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220413232024691.png" alt="image-20220413232024691" style="zoom:50%;" />



## 本地Windows开发

部署的东西不能来回改，需要本地对照

### 配置nginx

- 下载nginx并解压

- 修改配置文件nginx.conf，配置本地图片资源端口，启动nginx.exe

  ```nginx
  #蘑菇博客图片资源
  server {
   listen       8600;
   server_name  localhost;
   add_header Access-Control-Allow-Origin *;
   add_header Access-Control-Allow-Methods *;
   add_header Access-Control-Allow-Headers *;
   if ($request_method = 'OPTIONS') {
     return 204;
   }	
   location / {
  	root   D:\mogu_blog\data; # 图片存储目录
  	index  index.html index.htm;
   }
  }
  ```

  这里的存储目录根据自身电脑配置。

- 配置后需要同步到mogu_picture服务的配置文件

  如果是nacos分支，需要在nacos中进行修改。

  ```yaml
  #Data image url
  file:
    upload:
      path: D:/mogu_blog/data
  ```

- 校验：在存储位置放置图片111.jpg，访问localhost:8600/111.jpg成功即可

### 配置redis

1. 下载Redis,下载地址：https://github.com/MicrosoftArchive/redis/releases

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_09.png)

2. 下载完后解压到指定目录

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_10.png)

3. 启动redis-server.exe，默认配置文件redis.windows-service.conf

4. 根据情况修改redis密码，代码默认是mogu2018

   ```powershell
   # 编辑redis.windows-service.conf文件，配置密码
   requirepass mogu2018
   ```

5. 校验是否启动

   通过工具登录localhost:6379 确认是否连接成功

### 配置RabbitMQ

1. 安装Erlang，下载地址：http://erlang.org/download/otp_win64_21.3.exe

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_53.png)

   

2. 安装RabbitMQ，下载地址：https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_54.png)

3. 安装时已经启动，找到这个进程启动

   ![image-20220412131517627](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412131517627.png)

4. 进入RabbitMQ安装目录下的sbin目录

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_55.png)

   启动图形化界面

   ```powershell
   rabbitmq-plugins enable rabbitmq_management
   ```

5. 校验启动成功，访问http://localhost:15672

   默认账号 guest guest

   ![http://image.moguit.cn/1543898558218.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1543898558218.png)

6. 不使用默认账号，创建账号并设为管理员

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_58.png)

7. 创建一个新的虚拟host为：/blog

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_59.png)

8. 登录刚创建的账号，将host分配给该账号

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_60.png)

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_61.png)

9. 配置交换机和队列被代码完成了，原理暂时跳过，后续研究 https://www.moguit.cn/info/324

   手动配置方式放在这里

   - 配置交换机，起名为exchange.direct

     ![http://image.moguit.cn/1543898620061.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1543898620061.png)

     ![http://image.moguit.cn/1543898701072.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1543898701072.png)

   - 配置 Queues队列，mogu.blog  mogu.email  mogu.sms三个

     ![http://image.moguit.cn/1543898768504.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1543898768504.png)

   - 给交换机绑定队列

     ![http://image.moguit.cn/1543898845971.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1543898845971.png)

     ![http://image.moguit.cn/1543898914615.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1543898914615.png)

10. 这里手动配置了虚拟host，而原代码使用的是根目录/

    需要修改配置文件

    ```yaml
    spring:
      #RabbitMq
      rabbitmq:
        host: 127.0.0.1 #rabbitmq的主机ip
        port: 5672
        username: blog
        password: blog
        virtual-host: /blog # rabbitmq的虚拟host
    ```

11. 另外如果选择手动创建，启动可能报错

    ```powershell
    Channel shutdown: channel error; protocol method: #method<channel.close>(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg 'type' for exchange 'exchange.direct' in vhost '/blog': received 'direct' but current is 'fanout', class-id=40, method-id=10)
    ```

    原因是名为为"xxx"的这个exchange已经存在且为"广播"类型，现在尝试将其修改为"定向推送"，也就是需要修改交换机的类型。RabbitMQ中一旦创建了exchange是不允许对其改变的，如果尝试对其进行变更就会出现此错误提示，如果仍要进行此操作可删除这个exchange再试。

    ![image-20220412231730492](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412231730492.png)

### 配置Mysql

从拉取的项目中访问doc目录

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/9ab9d34c2c2541cab0d69ad66043547e.jpg)

```yaml
mogu_blog.sql: 代表mogu_blog数据库的文件

mogu_blog_update.sql: 代表mogu_blog在后续开发时候更新的字段（首次无需导入）

mogu_picture.sql: 代表mogu_picture数据库文件

mogu_picture_update.sql: 代表mogu_picture在后续开发时候更新的字段（首次不需要导入）

nacos_config.sql: 代表nacos的配置信息，用来存放每个模块的配置信息【nacos分支需要导入】
```

执行mogu_blog.sql/mogu_picture.sql，创建好 mogu_blog 、mogu_picture 、nacos_config 这三个数据库。

配置数据库密码，和配置文件同步【Nacos分支，配置文件存储在Nacos中，执行nacos_config.sql脚本】

### 配置Nacos

- 下载安装包到本地https://github.com/alibaba/nacos/releases

  ![image-20200814144224359](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/df299cd97ca04c51a9d6ad46259223aa.jpg)

- 解压，并进入conf目录，修改application.properties文件，添加本地数据库配置

  ```properties
  # mysql配置
  spring.datasource.platform=mysql
  db.num=1
  db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
  db.user=root
  db.password=root
  ```

  > 这里的数据库实际上来源于Nacos自带的/conf/nacos-mysql.sql

- 进入bin目录，以单机模式启动nacos

  ```powershell
  startup.cmd -m standalone
  ```

- 启动完成，访问http://localhost:8848/nacos  默认账号密码nacos 

  ![image-20200814151027589](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/c14a178fa20343899e678d6d7dc6239c.jpg)

- 在配置列表-dev可以修改本地配置

  ![image-20200814151141045](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/0eb5be4bee844b49bd498cd90e80e4f9.jpg)

配置Nacos后只需要启动四个微服务

![image-20200814154136820](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/e36915b0af384a4da5cb471ba1e301de.jpg)





### 启动后端

*Nacos版本：需要启动 ：mogu_gateway -> mogu_picture -> mogu_sms -> mogu_admin -> mogu_web*

启动过程略

#### 对应接口文档

admin: http://localhost:8601/swagger-ui/index.html

picture: http://localhost:8602/swagger-ui/index.html

web: http://localhost:8603/swagger-ui/index.html

使用了网关gateway作为微服务入口，屏蔽了服务端口，所以测试走Knife4j聚合

http://localhost:8607/doc.html

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/a2a5e311810248cb9f50f35a5bfcec45.jpg)



### 启动前端

- 下载nodejs并安装 https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi

  ```shell
  # 检查是否安装成功
  npm -v
  ```

- 安装 vue_mogu_admin 项目的依赖

  ```shell
  # 进入vue_mogu_admin目录
  npm install --registry=https://registry.npm.taobao.org
  
  # 启动项目 
  npm run dev
  
  #打包项目（在部署的时候才需要使用）
  npm run build
  ```

  访问地址http://localhost:9528  账号密码admin, mogu2018

- 同理安装vue_mogu_web依赖

  访问地址http://localhost:9527



### **配置ElasticSearch**【非必须】

完了，我装的是7.6.2...，后续需要调整配置和代码，这个后续补充

1. 下载Elasticsearch6.2.2的zip包，下载地址 https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-2-2

   并解压到指定目录

   ![](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_25.png)

2. 安装ik中文分词插件，下载地址 https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.2/elasticsearch-analysis-ik-6.2.2.zip，版本与es保持一致

   在elasticsearch-6.2.2\bin目录下执行以下命令：

   ```shell
   elasticsearch-plugin install 
   ```

   或者直接解压到es目录下的plugins目录（没试过，不保证）

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_26.png)

   ![image-20220412165345749](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412165345749.png)

3. 修改elasticsearch配置文件

   Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。

   修改config/jvm.options

   ```shell
   # 默认配置 内存占用较大
   -Xms1g
   -Xmx1g
   # 修改为
   -Xms512m
   -Xmx512m
   ```

   修改config/elasticsearch.yml文件，改为本地目录

   ```yaml
   path.data: E:\soft\elasticsearch-7.6.2\data # 数据目录位置
   path.log: E:\soft\elasticsearch-7.6.2\logs # 日志目录位置
   # 如果允许外部访问则配置
   network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问
   ```

4. 运行bin目录下的elasticsearch.bat启动Elasticsearch，绑定两个端口9200 9300

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_27.png)

5. 绑定两个端口 9200/9300

   - 9300：集群节点间通讯接口
   - 9200：客户端访问接口

   可以访问 http://localhost:9200

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1580090468834.png)

6. 下载Kibana,作为访问Elasticsearch的客户端，下载地址：https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-windows-x86_64.zip

   并解压到指定目录

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_28.png)

7. 修改配置文件config/kibana.yml

   ```yaml
   elasticsearch.url: "http://localhost:9200"
   ```

   不同版本似乎不太一样，我这边7.6.2的配置是

   ```yaml
   elasticsearch.hosts: ["http://localhost:9200"]
   ```

   默认就是本地9200，可以不用修改配置

8. 运行bin目录下的kibana.bat，启动Kibana的用户界面

   ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_29.png)

9. 访问[http://localhost:5601](http://localhost:5601/) 即可打开Kibana的用户界面

10. 选择左侧的DevTools菜单，即可进入控制台页面

    ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1580090629213.png)

    在页面右侧，我们就可以输入请求，访问Elasticsearch了

    ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1580090642926.png)

#### 测试

在kibana控制台输入下面的请求：

```json
POST _analyze
{
  "analyzer": "ik_max_word",
  "text":     "我是中国人"
}
```

得到运行结果

```json
{
  "tokens": [
    {
      "token": "我",
      "start_offset": 0,
      "end_offset": 1,
      "type": "CN_CHAR",
      "position": 0
    },
    {
      "token": "是",
      "start_offset": 1,
      "end_offset": 2,
      "type": "CN_CHAR",
      "position": 1
    },
    {
      "token": "中国人",
      "start_offset": 2,
      "end_offset": 5,
      "type": "CN_WORD",
      "position": 2
    },
    {
      "token": "中国",
      "start_offset": 2,
      "end_offset": 4,
      "type": "CN_WORD",
      "position": 3
    },
    {
      "token": "国人",
      "start_offset": 3,
      "end_offset": 5,
      "type": "CN_WORD",
      "position": 4
    }
  ]
}
```

![image-20220412170315414](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220412170315414.png)

> Kibana只是作为ElasticSearch的图形化显示工具，在生产环境中，可以不部署。



### 配置zipkin链路追踪

Zipkin是一个开源的分布式的链路追踪系统，每个微服务都会向zipkin报告计时数据，聚合各业务系统调用延迟数据，达到链路调用监控跟踪。

#### 用途

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/98244924866348bc868de2e1d33bf10d.jpg)

在复杂的调用链路中假设存在一条调用链路响应缓慢，如何定位其中延迟高的服务呢？

- 日志： 通过分析调用链路上的每个服务日志得到结果
- zipkin：使用`zipkin`的`web UI`可以一眼看出延迟高的服务

各业务系统在彼此调用时，将特定的跟踪消息传递至`zipkin`，zipkin在收集到跟踪信息后将其聚合处理、存储、展示等，用户可通过`web UI`方便获得网络延迟、调用链路、系统依赖等等。

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/94326670ae254584a8b20b1d5bcba219.jpg)

> 在使用zipkin链路追踪的时候，需要提前启动zipkin服务，然后在启动博客项目，这样才能够正常的将服务调用的信息注册到zipkin中

#### 安装

- 下载 zipkin https://search.maven.org/remote_content?g=io.zipkin.java&a=zipkin-server&v=LATEST&c=exec

- 内存运行

  ```shell
  java -jar zipkin-server-2.12.5-exec.jar
  # 或集成RabbitMQ
  java -jar zipkin-server-2.12.5-exec.jar --zipkin.collector.rabbitmq.addresses=127.0.0.1
  ```

  ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/37efae8ca70042d29b3f73dcad87d2c8.jpg)

- 选择用mysql存储收集信息

  创建数据库zipkin，执行[sql脚本](https://github.com/openzipkin/zipkin/blob/master/zipkin-storage/mysql-v1/src/main/resources/mysql.sql)，增加几张表

  ```mysql
  CREATE TABLE IF NOT EXISTS zipkin_spans (
    `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
    `trace_id` BIGINT NOT NULL,
    `id` BIGINT NOT NULL,
    `name` VARCHAR(255) NOT NULL,
    `remote_service_name` VARCHAR(255),
    `parent_id` BIGINT,
    `debug` BIT(1),
    `start_ts` BIGINT COMMENT 'Span.timestamp(): epoch micros used for endTs query and to implement TTL',
    `duration` BIGINT COMMENT 'Span.duration(): micros used for minDuration and maxDuration query',
    PRIMARY KEY (`trace_id_high`, `trace_id`, `id`)
  ) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
  
  ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTracesByIds';
  ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT 'for getTraces and getSpanNames';
  ALTER TABLE zipkin_spans ADD INDEX(`remote_service_name`) COMMENT 'for getTraces and getRemoteServiceNames';
  ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT 'for getTraces ordering and range';
  
  CREATE TABLE IF NOT EXISTS zipkin_annotations (
    `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
    `trace_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.trace_id',
    `span_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.id',
    `a_key` VARCHAR(255) NOT NULL COMMENT 'BinaryAnnotation.key or Annotation.value if type == -1',
    `a_value` BLOB COMMENT 'BinaryAnnotation.value(), which must be smaller than 64KB',
    `a_type` INT NOT NULL COMMENT 'BinaryAnnotation.type() or -1 if Annotation',
    `a_timestamp` BIGINT COMMENT 'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp',
    `endpoint_ipv4` INT COMMENT 'Null when Binary/Annotation.endpoint is null',
    `endpoint_ipv6` BINARY(16) COMMENT 'Null when Binary/Annotation.endpoint is null, or no IPv6 address',
    `endpoint_port` SMALLINT COMMENT 'Null when Binary/Annotation.endpoint is null',
    `endpoint_service_name` VARCHAR(255) COMMENT 'Null when Binary/Annotation.endpoint is null'
  ) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
  
  ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT 'Ignore insert on duplicate';
  ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT 'for joining with zipkin_spans';
  ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTraces/ByIds';
  ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT 'for getTraces and getServiceNames';
  ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT 'for getTraces and autocomplete values';
  ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT 'for getTraces and autocomplete values';
  ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT 'for dependencies job';
  
  CREATE TABLE IF NOT EXISTS zipkin_dependencies (
    `day` DATE NOT NULL,
    `parent` VARCHAR(255) NOT NULL,
    `child` VARCHAR(255) NOT NULL,
    `call_count` BIGINT,
    `error_count` BIGINT,
    PRIMARY KEY (`day`, `parent`, `child`)
  ) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
  ```

- 改用如下指令启动zipkin

  ```shell
  java -jar zipkin-server-2.12.5-exec.jar --STORAGE_TYPE=mysql --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=root --MYSQL_HOST=localhost --MYSQL_TCP_PORT=3306
  ```



### 配置Sentinel流量控制【非必须】

Sentinel存在于Nacos分支下，Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

#### 与Hystrix的区别

Hystrix存在的问题

- 需要我们程序员自己手工搭建监控平台
- 没有一套web界面可以给我们进行更加细粒度化的配置，流量控制，速率控制，服务熔断，服务降级..

这个时候Sentinel运营而生

- 单独一个组件，可以独立出来
- 直接界面化的细粒度统一配置

#### 安装（待补充）

https://www.moguit.cn/info/198







## 使用DockerCompose安装启动

原来的部署方式是采用单个Docker镜像来进行部署的，每次拉取一个超大型的镜像【大概5G】，如果在拉取镜像的时候，遇到网络卡顿等外界影响，很容易导致拉取失败，同时因为这种部署方式不太符合微服务架构的思想。

### 安装Docker Compose

下载 https://github.com/docker/compose/releases    docker-compose-Linux-x86_64

```shell
curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
```

```shell
# 移动到/usr/local/bin目录下并重命名
mv docker-compose-linux-x86_64 /usr/local/bin/docker-compose
# 加入执行权限
sudo chmod +x /usr/local/bin/docker-compose
# 查看docker-compose版本
docker-compose -v
```



### 开放端口

这个同Docker部署，用于访问

开放的地方包括阿里云安全组，以及防火墙。

```yaml
RabbitMQ消息队列: 15672
Zipkin链路追踪: 9411
发Email端口: 465   
图片资源: 8600   
前端Web页面: 9527    
后端Admin页面: 9528  
Redis: 6379   
Mysql: 3306   
Tomcat(里面部署的solr): 8080
HTTP端口: 80
Kibana端口: 5601
mogu_admin端口: 8601
mogu_picture端口: 8602
mogu_web端口: 8603
mogu_sms端口: 8604
mogu_search端口: 8605
mogu_monitor端口: 8606
mogu_gateway端口: 8607
nacos端口: 8848
sentinel端口: 8070
portainer端口: 9000
```



### 创建网络

分容器启动时，容器之间需要互相通信访问，需要创建Docker网络

```bash
docker network create mogu
```

现在没有能力自己配，所以学习配好的文档

从项目中拷贝/doc/docker-compose 文件夹到服务器

![image-20201128215644896](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/3eebbd04b6594f1098530b44142cb76c.jpg)

目录结构：

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/93219faa15224ea581f3b365e3cb2d5e.jpg)

- bin：相关一键启动脚本的目录
  - completeStartup.sh：完整版启动脚本
  - completeShutdown.sh：完整版关闭脚本
  - kernStartup.sh：核心版启动脚本【只包含必要的组件】
  - kernShutdown.sh：核心版关闭脚本
  - update.sh：用于更新镜像【同步最新代码时使用】
- config：存放配置文件
- data：存放数据文件
- log：存放日志文件
- yaml：存放docker compose的yaml文件



位置随意，这里放置在了/root/docker-compose目录，之后默认按这个。然后给bin目录的指令赋予执行权限

```shell
# 进入目录
cd docker-compose
# 添加执行权限
chmod +x bin/kernStartup.sh
chmod +x bin/kernShutdown.sh
chmod +x bin/update.sh
chmod +x bin/wait-for-it.sh
# 我个人用的是
chmod -R +x bin/
```



### 修改前端配置

这个启动的是拉下来的蘑菇的前端配置，所以前端的ip地址需要替换为自己的，域名也是

#### 方式一 自动修改

执行bin目录的py脚本，效果是自动获取服务器ip，替换配置文件

```shell
# 进入到bin目录
cd bin
# 执行脚本
python2 replaceIp.py
```

#### 方式二 手动修改

直接修改前端配置文件本身，这里前端使用的配置文件放在了docker-compose/config里

```shell
# 修改vue_mogu_admin项目配置
vim config/vue_mogu_admin.env

# 修改vue_mogu_web项目配置
vim config/vue_mogu_web.env
```

可以使用vim全局替换，域名的话类似

```shell
# :%s/原ip地址/现ip地址/g
:%s/120.78.126.96/192.168.177.150/g
```



### 开始部署

进入bin目录执行核心服务启动，

```shell
# 进入到bin目录 因为使用的是相对目录，所以必须进入这个目录再执行脚本
cd bin
# 启动一键部署脚本 【核心版脚本】
sh kernStartup.sh
# 一键关闭【需要关闭时使用】
sh kernShutdown.sh
```

> *如果执行一键部署脚本 kernStartup.sh 的时候，出现 $'\r': command not found 文件*
>
> 可能是因为windows与Unix文本编辑器默认格式不同引起的，因此需要进行转换
>
> ```shell
> # 安装 dos2unix
> yum -y install dos2unix*
> # 转换脚本
> dos2unix kernStartup.sh
> dos2unix kernShutdown.sh
> dos2unix update.sh
> dos2unix wait-for-it.sh
> # 个人全转换了
> dos2unix *.sh
> ```

执行效果是启动容器。没有容器就创建容器，如果本地没有的镜像，就从仓库中拉取。

通过指令查看镜像情况

```shell
docker images
```

查看容器启动情况

```shell
docker ps -a
```

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1c4676e6cb494b5080c5b5038629e987.jpg)

从STATUS获取启动是否成功，如果没有成功，可以在脚本中找到对应容器的启动指令，如

```shell
docker-compose -f yaml/portainer.yml up -d
```



### 运行测试

安装了Portainer容器可视化工具，主要进行Docker容器的状态监控，以及镜像和容器的安装。

```shell
# 启动脚本 需要可以配进启动脚本里
docker-compose -f /root/docker-compose/yaml/portainer.yml up -d
```

访问  http://ip:9000【首次需要创建密码，选择local环境】

![image-20220414233125916](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220414233125916.png)

其他服务直接访问对应网址即可，账号密码按照默认的。





### 个人适配

1. Nacos配置文件 对应服务修改好配置，参考其他搭建

2. 默认只能通过ip地址访问网站，需要修改nginx

   ```shell
   vim /root/docker-compose/config/mogu_data.conf # 位置根据你自己放文件的位置来
   ```

   ```nginx
       server {
           listen       80;
           server_name  picture.moguit.cn;
   
           add_header Access-Control-Allow-Origin *;
           add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
           add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,lang,access-token';
           if ($request_method = 'OPTIONS') {
            return 204;
           }
   
           location / {
                   root   /home/mogu_blog/mogu_data/;
                   index  index.html index.htm;
           }
       }
   
       server {
           listen       8600;
           server_name  localhost;
   
           add_header Access-Control-Allow-Origin *;
           add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
           add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,lang,access-token';
           if ($request_method = 'OPTIONS') {
            return 204;
           }
   
           location / {
                   root   /home/mogu_blog/mogu_data/;
                   index  index.html index.htm;
           }
       }
   
   	# 网关
   	server {
           listen      80;
           server_name gateway.moguit.cn;
           location / {
             proxy_pass   http://mogu_gateway/;
           }
       }
   
      # 前台前端
      server {
           listen      80;
           server_name www.moguit.cn;
           location / {
             proxy_pass   http://vue_mogu_web/;
           }
       }
   
   	# 后台前端
       server {
           listen       80;
           server_name  admin.moguit.cn;
           location / {
              proxy_pass   http://vue_mogu_admin/;
           }
       }
   ```

3. 重启修改了配置的容器，相当于之前的重启服务

   ```shell
   cd /root/docker-compose/yaml
   # 重启
   docker-compose -f mogu_data.yml restart # 这个应该是重启后端服务
   docker-compose -f vue_mogu_admin.yml restart # 重启后台前端
   docker-compose -f vue_mogu_web.yml restart # 重启前台前端
   ```

4. 查看日志

   ```shell
   docker logs 容器名
   ```





# 蘑菇博客架构技术个人记录

## 架构图

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/df64ec5529874d849b272525d1d0.jpg)



## 个人配置

###  配置Nacos通过IDEA启动

目前的Nacos本地启动通过指令，不方便与项目放在一起管理，所以将Nacos启动关闭配置在IDEA中进行。

- 在启动服务器的配置里选择新建配置

  ![image-20220423180701702](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220423180701702.png)

- 选择Shell Script脚本，如下配置：

  - Script path： Nacos的startup.cmd的文件路径
  - Script options： -m standalone 也就是执行的额外条件，单机启动

  ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/9750a4825ebe410b9d73c6b39b34d3c1.jpg)

配置后，可以在IDEA右上角通过脚本启动

![image-20220423182427495](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220423182427495.png)



### 拉取Nacos项目启动Nacos

#### 获取源码

访问Github官网，进入Nacos源代码主页：https://github.com/alibaba/nacos，可以通过Git工具下载Nacos源码

![image-20220423231815073](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220423231815073.png)

> 目前的项目匹配的应该是nacos 的1.4.x版本，而nacos的master分支目前是2.0版本，需要切换分支到1.X



#### 使用IDEA打开项目



![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/ssddsfdsdfsdffsdd324234234234.png)



#### 配置个人数据库到配置文件

位置是console/src/main/resource/application.properties 改动的内容同mogu的Nacos的application.properties 文件。

![截屏20220303 13.04.05.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/fdfsdfsihfusdf83333.png)

```properties
server.port=8848
spring.datasource.platform=mysql
db.num=1
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
db.user.0=root
db.password.0=root
```



可以顺便把配置好的数据库sql文件也同步过来，位置是distribution/conf/nacos-mysql.sql

![截屏20220303 12.56.00.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/ddgdsfgsgfsgsdg448.png)



#### 安装Protobuf插件

拉取项目后会有部分类无法导入，提示

```shell
java: 程序包com.alibaba.nacos.consistency.entity不存在
```

原因：https://github.com/alibaba/nacos/issues/7062

![image](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/137059397-6d49198c-4e20-4d0b-8927-41b47f8fad24.png)

需要使用Protobuf插件对项目源码进行编译

打开Preferences/Plugins/Marketplace，搜索protobuf并安装，安装成功后重启IDEA。

![截屏20220303 14.27.40.png](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/1646293585423.png)

然后在nacos-consistency项目下找到插件，执行compile

![image-20220430010017265](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220430010017265.png)

如果不想安装插件，可以直接全局install项目，然后再启动。

> 个人执行compile没有成功，使用的是`mvn clean install`
>
> 另外，install过程提示Too many files with unapproved license报错打包失败，可以添加参数再执行：
>
> ```shell
> mvn clean install -DskipTests -Drat.skip=true
> ```
>
> 效果是跳过许可证批准的判断



#### 配置启动参数

选择console模块，点击Add Configuration... 按钮，进入配置面板，点击Add new run configuration..配置启动参数。配置参数如下：

```tex
-Dnacos.standalone=true
```

![image-20220423234906461](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220423234906461.png)



### 配置nginx通过IDEA启动

同上，为了方便可控。

#### 安装插件Nginx Support

打开Preferences/Plugins/Marketplace，搜索Nginx Support并安装，安装成功后重启IDEA。

![image-20220424142744928](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220424142744928.png)

#### 配置启动参数

点击Add Configuration... 按钮，进入配置面板，选择添加nginx server，选择已经装好的nginx程序

![image-20220424143450982](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220424143450982.png)

![image-20220424145444030](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220424145444030.png)



## 结构解析记录

### mogu_admin







# mall项目

## 整合SpringSecurity和JWT实现认证授权

### 权限数据表

```mysql
user_admin: 后台用户表
user_role: 后台用户角色表
user_permission: 后台用户权限表
user_admin_role_relation: 用户角色关联表
user_role_permission_relation: 角色权限关联表
user_admin_permission_relation: 用户权限关系表，设置的是除了角色权限外的增减权限
```

### 配置SecurityConfig

```java
/**
 * SpringSecurity的配置
 * Created by macro on 2018/4/26.
 */
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled=true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private UmsAdminService adminService;
    @Autowired
    private RestfulAccessDeniedHandler restfulAccessDeniedHandler;
    @Autowired
    private RestAuthenticationEntryPoint restAuthenticationEntryPoint;

    @Override
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.csrf()// 由于使用的是JWT，我们这里不需要csrf
                .disable()
                .sessionManagement()// 基于token，所以不需要session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeRequests()
                .antMatchers(HttpMethod.GET, // 允许对于网站静态资源的无授权访问
                        "/",
                        "/*.html",
                        "/favicon.ico",
                        "/**/*.html",
                        "/**/*.css",
                        "/**/*.js",
                        "/swagger-resources/**",
                        "/v2/api-docs/**"
                )
                .permitAll()
                .antMatchers("/admin/login", "/admin/register")// 对登录注册要允许匿名访问
                .permitAll()
                .antMatchers(HttpMethod.OPTIONS)//跨域请求会先进行一次options请求
                .permitAll()
//                .antMatchers("/**")//测试时全部运行访问
//                .permitAll()
                .anyRequest()// 除上面外的所有请求全部需要鉴权认证
                .authenticated();
        // 禁用缓存
        httpSecurity.headers().cacheControl();
        // 添加JWT filter
        httpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class);
        //添加自定义未授权和未登录结果返回
        httpSecurity.exceptionHandling()
                .accessDeniedHandler(restfulAccessDeniedHandler)
                .authenticationEntryPoint(restAuthenticationEntryPoint);
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService())
                .passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        //获取登录用户信息
        return username -> {
            UmsAdmin admin = adminService.getAdminByUsername(username);
            if (admin != null) {
                List<UmsPermission> permissionList = adminService.getPermissionList(admin.getId());
                return new AdminUserDetails(admin,permissionList);
            }
            throw new UsernameNotFoundException("用户名或密码错误");
        };
    }

    @Bean
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter(){
        return new JwtAuthenticationTokenFilter();
    }

    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

}
```

> **@EnableGlobalMethodSecurity(prePostEnabled=true)**
>
> SpringSecurity开启注解校验接口是否需要验证，后续的属性配置允许使用表达式时间方法级别的安全性，可以使用4个注解：
>
> - **@PreAuthorize** 在方法调用之前，基于表达式的计算结果来限制对方法的访问
>
> - **@PostAuthorize** 允许方法调用，但是如果表达式计算结果为false，将抛出一个安全性异常
> - **@PostFilter** 允许方法调用，但必须按照表达式来过滤方法的结果
> - **@PreFilter** 允许方法调用，但必须在进入方法之前过滤输入值

> **相关方法**
>
> - configure(HttpSecurity httpSecurity)：用于配置需要拦截的url路径、jwt过滤器及出异常后的处理器；
> - configure(AuthenticationManagerBuilder auth)：用于配置UserDetailsService及PasswordEncoder；
> - RestfulAccessDeniedHandler：当用户没有访问权限时的处理器，用于返回JSON格式的处理结果；
> - RestAuthenticationEntryPoint：当未登录或token失效时，返回JSON格式的结果；
> - UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现；
> - UserDetails：SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要自行实现；
> - PasswordEncoder：SpringSecurity定义的用于对密码进行编码及比对的接口，目前使用的是BCryptPasswordEncoder；
> - JwtAuthenticationTokenFilter：在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。

### 自定义RestfulAccessDeniedHandler

当用户没有访问权限时的处理器，用于返回JSON格式的处理结果；

```java
/**
 * 当访问接口没有权限时，自定义的返回结果
 * Created by macro on 2018/4/26.
 */
@Component
public class RestfulAccessDeniedHandler implements AccessDeniedHandler{
    @Override
    public void handle(HttpServletRequest request,
                       HttpServletResponse response,
                       AccessDeniedException e) throws IOException, ServletException {
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.getWriter().println(JSONUtil.parse(CommonResult.forbidden(e.getMessage())));
        response.getWriter().flush();
    }
}
```

### 自定义RestAuthenticationEntryPoint

当未登录或token失效时，返回JSON格式的结果；

```java
/**
 * 当未登录或者token失效访问接口时，自定义的返回结果  401
 * Created by macro on 2018/5/14.
 */
@Component
public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.getWriter().println(JSONUtil.parse(CommonResult.unauthorized(authException.getMessage())));
        response.getWriter().flush();
    }
}
```

### 自定义用户信息AdminUserDetails

封装用户信息的类（主要是用户信息和权限）

```java
/**
 * SpringSecurity需要的用户详情
 * Created by macro on 2018/4/26.
 */
public class AdminUserDetails implements UserDetails {
    private UmsAdmin umsAdmin;
    private List<UmsPermission> permissionList;
    public AdminUserDetails(UmsAdmin umsAdmin, List<UmsPermission> permissionList) {
        this.umsAdmin = umsAdmin;
        this.permissionList = permissionList;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        //返回当前用户的权限
        return permissionList.stream()
                .filter(permission -> permission.getValue()!=null)
                .map(permission ->new SimpleGrantedAuthority(permission.getValue()))
                .collect(Collectors.toList());
    }

    @Override
    public String getPassword() {
        return umsAdmin.getPassword();
    }

    @Override
    public String getUsername() {
        return umsAdmin.getUsername();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return umsAdmin.getStatus().equals(1);
    }
}
```

### 自定义JwtAuthenticationTokenFilter

在用户名和密码校验前添加的过滤器，如果有jwt的token，会自行根据token信息进行登录。

```java
/**
 * JWT登录授权过滤器
 * Created by macro on 2018/4/26.
 */
@Slf4j
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {
    @Autowired
    private UserDetailsService userDetailsService;
    @Autowired
    private JwtTokenUtil jwtTokenUtil;
    @Value("${jwt.tokenHeader}")
    private String tokenHeader;
    @Value("${jwt.tokenHead}")
    private String tokenHead;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        String authHeader = request.getHeader(this.tokenHeader);
        //	特定请求头
        if (authHeader != null && authHeader.startsWith(this.tokenHead)) {
            String authToken = authHeader.substring(this.tokenHead.length());// The part after "Bearer "
            String username = jwtTokenUtil.getUserNameFromToken(authToken);
            log.info("checking username:{}", username);
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
                if (jwtTokenUtil.validateToken(authToken, userDetails)) {
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    log.info("authenticated user:{}", username);
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```



## 整合SpringElasticSearch实现商品搜索

### 对应数据库表

- `pms_product`：商品信息表

  ```mysql
  # 省略无关属性
  CREATE TABLE `pms_product` (
    `id` bigint NOT NULL AUTO_INCREMENT,
    `brand_id` bigint DEFAULT NULL,
    `product_category_id` bigint DEFAULT NULL,
    `product_attribute_category_id` bigint DEFAULT NULL,
    `name` varchar(64) NOT NULL,
    `pic` varchar(255) DEFAULT NULL,
    `product_sn` varchar(64) NOT NULL COMMENT '货号',
    `delete_status` int DEFAULT NULL COMMENT '删除状态：0->未删除；1->已删除',
    `publish_status` int DEFAULT NULL COMMENT '上架状态：0->下架；1->上架',
    `new_status` int DEFAULT NULL COMMENT '新品状态:0->不是新品；1->新品',
    `recommand_status` int DEFAULT NULL COMMENT '推荐状态；0->不推荐；1->推荐',
    `verify_status` int DEFAULT NULL COMMENT '审核状态：0->未审核；1->审核通过',
    `sort` int DEFAULT NULL COMMENT '排序',
    `sale` int DEFAULT NULL COMMENT '销量',
    `price` decimal(10,2) DEFAULT NULL,
    `sub_title` varchar(255) DEFAULT NULL COMMENT '副标题',
    `description` text COMMENT '商品描述',
    `original_price` decimal(10,2) DEFAULT NULL COMMENT '市场价',
    `stock` int DEFAULT NULL COMMENT '库存',
    `keywords` varchar(255) DEFAULT NULL,
    `album_pics` varchar(255) DEFAULT NULL COMMENT '画册图片，连产品图片限制为5张，以逗号分割',
    `detail_title` varchar(255) DEFAULT NULL,
    `promotion_type` int DEFAULT NULL COMMENT '促销类型：0->没有促销使用原价;1->使用促销价；2->使用会员价；3->使用阶梯价格；4->使用满减价格；5->限时购',
    `brand_name` varchar(255) DEFAULT NULL COMMENT '品牌名称',
    `product_category_name` varchar(255) DEFAULT NULL COMMENT '商品分类名称',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COMMENT='商品信息';
  ```

  

- `pms_product_attribute`：商品属性参数表

  ```mysql
  CREATE TABLE `pms_product_attribute` (
    `id` bigint NOT NULL AUTO_INCREMENT,
    `product_attribute_category_id` bigint DEFAULT NULL,
    `name` varchar(64) DEFAULT NULL,
    `select_type` int DEFAULT NULL COMMENT '属性选择类型：0->唯一；1->单选；2->多选',
    `input_type` int DEFAULT NULL COMMENT '属性录入方式：0->手工录入；1->从列表中选取',
    `input_list` varchar(255) DEFAULT NULL COMMENT '可选值列表，以逗号隔开',
    `sort` int DEFAULT NULL COMMENT '排序字段：最高的可以单独上传图片',
    `filter_type` int DEFAULT NULL COMMENT '分类筛选样式：1->普通；1->颜色',
    `search_type` int DEFAULT NULL COMMENT '检索类型；0->不需要进行检索；1->关键字检索；2->范围检索',
    `related_status` int DEFAULT NULL COMMENT '相同属性产品是否关联；0->不关联；1->关联',
    `hand_add_status` int DEFAULT NULL COMMENT '是否支持手动新增；0->不支持；1->支持',
    `type` int DEFAULT NULL COMMENT '属性的类型；0->规格；1->参数',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=52 DEFAULT CHARSET=utf8 COMMENT='商品属性参数表';
  ```

  

- `pms_product_attribute_value`：存储产品参数值的表

  ```mysql
  CREATE TABLE `pms_product_attribute_value` (
    `id` bigint NOT NULL AUTO_INCREMENT,
    `product_id` bigint DEFAULT NULL,
    `product_attribute_id` bigint DEFAULT NULL,
    `value` varchar(64) DEFAULT NULL COMMENT '手动添加规格或参数的值，参数单值，规格有多个时以逗号隔开',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=275 DEFAULT CHARSET=utf8 COMMENT='存储产品参数信息的表';
  ```

  

### 创建对应商品文档对象EsProduct

是一个实体类，就像实体类映射数据库表一样，去映射es的类型

```java
@Data
@Document(indexName = "pms", shards = 1, replicas = 0)
public class EsProduct implements Serializable {
    @Id
    private Long id;
    /**
     * 货号
     */
    @Field(type = FieldType.Keyword)
    private String productSn;

    private Long brandId;

    @Field(type = FieldType.Keyword)
    private String brandName;

    private Long productCategoryId;

    @Field(type = FieldType.Keyword)
    private String productCategoryName;

    private String pic;

    /**
     * 商品名  需要中文分词
     */
    @Field(analyzer = "ik_max_word", type = FieldType.Text)
    private String name;

    @Field(analyzer = "ik_max_word", type = FieldType.Text)
    private String subTitle;

    @Field(analyzer = "ik_max_word", type = FieldType.Text)
    private String keywords;

    private BigDecimal price;
    /**
     * 销量
     */
    private Integer sale;
    /**
     * 新品状态:0->不是新品；1->新品
     */
    private Integer newStatus;
    /**
     * 推荐状态；0->不推荐；1->推荐
     */
    private Integer recommandStatus;
    /**
     * 库存
     */
    private Integer stock;
    /**
     * 促销类型：0->没有促销使用原价;1->使用促销价；2->使用会员价；3->使用阶梯价格；4->使用满减价格；5->限时购
     */
    private Integer promotionType;

    private Integer sort;

    @Field(type = FieldType.Nested)
    private List<EsProductAttributeValue> attrValueList;
}
```

包含一个集合属性-商品的属性集attrValueList，其对应类为商品的属性信息EsProductAttributeValue

```java
@Data
public class EsProductAttributeValue implements Serializable {

    private Long id;
    private Long productAttributeId;
    /**
     * 属性值 手动添加规格或参数的值，参数单值，规格有多个时以逗号隔开
     */
    @Field(type = FieldType.Keyword)
    private String value;
    /**
     * 属性参数：0->规格；1->参数
     */
    private Integer type;
    /**
     * 属性名称
     */
    @Field(type=FieldType.Keyword)
    private String name;

}
```

### 创建ES操作实体类数据的接口EsProductRepository

继承一个官方接口ElasticsearchRepository，自带一些方法，表示基础的操作，定义一个衍生的查询方法

```java
@Repository	//	要被扫描到
public interface EsProductRepository extends ElasticsearchRepository<EsProduct, Long> {

    /**
     * 找到名字或子标题或关键词
     *
     * @param name     商品名称
     * @param subTitle 商品标题
     * @param keywords 商品关键字
     * @param page     分页信息
     * @return {@link Page}<{@link EsProduct}>
     */
    Page<EsProduct> findByNameOrSubTitleOrKeywords (String name, String subTitle, String keywords, Pageable page);

}
```

这里虽然是自定义方法findByNameOrSubTitleOrKeywords，但实际上类似JPA，按照实体类的属性在findBy后面添加要搜索的属性。

### 配置Mybatis数据库查询

用于将数据录入es

#### 配置文件application.yml

```yaml
# 数据库配置
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mall?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
    username: root
    password: root
# mapper文件扫描配置
mybatis:
  mapper-locations:
    - classpath:dao/*.xml
```



#### SQL文件EsProductDao.xml

包含一个连表查询getAllEsProductList，根据id查询未删除，已发布的商品及其所有属性值

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.pix.mall.dao.EsProductDao">
    <resultMap id="esProductListMap" type="com.pix.mall.domain.EsProduct" autoMapping="true">
        <id column="id" jdbcType="BIGINT" property="id"/>
        <collection property="attrValueList" columnPrefix="attr_" ofType="com.pix.mall.domain.EsProductAttributeValue">
            <id column="id" property="id" jdbcType="BIGINT"/>
            <result column="product_attribute_id" property="productAttributeId" jdbcType="BIGINT"/>
            <result column="value" property="value" jdbcType="VARCHAR"/>
            <result column="type" property="type"/>
            <result column="name" property="name"/>
        </collection>
    </resultMap>
    <select id="getAllEsProductList" resultMap="esProductListMap">
        select
        p.id id,
        p.product_sn productSn,
        p.brand_id brandId,
        p.brand_name brandName,
        p.product_category_id productCategoryId,
        p.product_category_name productCategoryName,
        p.pic pic,
        p.name name,
        p.sub_title subTitle,
        p.price price,
        p.sale sale,
        p.new_status newStatus,
        p.recommand_status recommandStatus,
        p.stock stock,
        p.promotion_type promotionType,
        p.keywords keywords,
        p.sort sort,
        pav.id attr_id,
        pav.value attr_value,
        pav.product_attribute_id attr_product_attribute_id,
        pa.type attr_type,
        pa.name attr_name
        from pms_product p
        left join pms_product_attribute_value pav on p.id = pav.product_id
        left join pms_product_attribute pa on pav.product_attribute_id= pa.id
        where p.delete_status = 0 and p.publish_status = 1
        <if test="id!=null">
            and p.id=#{id}
        </if>
    </select>
</mapper>
```

#### Dao层EsProductDao

用于映射，需要配置扫描到这个文件

```java
public interface EsProductDao {
    /**
     * 获取指定ID的搜索商品
     */
    List<EsProduct> getAllEsProductList(@Param("id") Long id);
}
```

### 创建ES商品服务类及其实现

#### 服务接口EsProductService

```java
public interface EsProductService {

    /**
     * 数据库导入所有商品信息到es
     *
     * @return int
     */
    int importAll();

    /**
     * 根据id删除商品
     *
     * @param id id
     */
    void delete(Long id);

    /**
     * 根据id创建商品
     *
     * @param id id
     * @return {@link EsProduct}
     */
    EsProduct create(Long id);


    /**
     * 根据id批量删除商品
     *
     * @param id id
     */
    void delete(List<Long> id);

    /**
     * 根据关键字搜索名称或者副标题
     *
     * @param keywords 关键字
     * @param pageNum  页面num
     * @param pageSize 页面大小
     * @return {@link Page}<{@link EsProduct}>
     */
    Page<EsProduct> search(String keywords, Integer pageNum, Integer pageSize);
}
```

#### 服务实现类EsProductServiceImpl

```java
@Slf4j
@Service
public class EsProductServiceImpl implements EsProductService {
    @Autowired
    private EsProductRepository esProductRepository;
    @Autowired
    private EsProductDao esProductDao;

    @Override
    public int importAll() {
        //  查询所有搜索商品信息
        List<EsProduct> allEsProductList = esProductDao.getAllEsProductList(null);
        Iterable<EsProduct> esProducts = esProductRepository.saveAll(allEsProductList);
        int result = 0;
        for (EsProduct esProduct : esProducts) {
            result++;
        }
        return result;
    }

    @Override
    public void delete(Long id) {
        esProductRepository.deleteById(id);
    }

    @Override
    public EsProduct create(Long id) {
        EsProduct product = null;
        List<EsProduct> allEsProductList = esProductDao.getAllEsProductList(id);
        if(CollUtil.isNotEmpty(allEsProductList)){
            product = esProductRepository.save(allEsProductList.get(0));
        }
        return product;
    }

    @Override
    public void delete(List<Long> idList) {
        if(CollUtil.isNotEmpty(idList)){
            List<EsProduct> delProductList = idList.stream().map(id->{
                EsProduct product = new EsProduct();
                product.setId(id);
                return product;
            }).collect(Collectors.toList());
            esProductRepository.deleteAll(delProductList);
        }
    }

    @Override
    public Page<EsProduct> search(String keywords, Integer pageNum, Integer pageSize) {
        Pageable pageable = PageRequest.of(pageNum,pageSize);
        return esProductRepository.findByNameOrSubTitleOrKeywords(keywords,keywords,keywords,pageable);
    }
}
```

### 创建对应接口

```java
@RestController
@RequestMapping("/esProduct")
public class EsProductController {
    @Autowired
    private EsProductService esProductService;

    /**
     * 导入所有数据库中商品到ES
     *
     * @return int
     */
    @PostMapping("/importAll")
    public int importAll() {
        return esProductService.importAll();
    }

    /**
     * 根据id删除商品
     *
     * @param id id
     */
    @GetMapping("/delete/{id}")
    public void deleteById(@PathVariable("id") Long id) {
        esProductService.delete(id);
    }

    /**
     * 根据id批量删除商品
     *
     * @param ids id
     */
    @PostMapping("/delete/batch")
    public void deleteBatch(@RequestParam("ids") List<Long> ids) {
        esProductService.delete(ids);
    }

    /**
     * 根据id创建商品
     *
     * @param id id
     * @return {@link EsProduct}
     */
    @PostMapping("create/{id}")
    public EsProduct create(@PathVariable("id") Long id) {
        return esProductService.create(id);
    }

    /**
     * 简单搜索
     *
     * @param keywords 关键字
     * @param pageNum  页面num
     * @param pageSize 页面大小
     * @return {@link Page}<{@link EsProduct}>
     */
    @GetMapping("/search")
    public Page<EsProduct> search(@RequestParam(required = false) String keywords,
                                  @RequestParam(required = false, defaultValue = "0") Integer pageNum,
                                  @RequestParam(required = false, defaultValue = "5") Integer pageSize) {
        return esProductService.search(keywords, pageNum, pageSize);
    }
}
```

> 这里的删除与插入都是指es库内的删除，不会影响数据库数据。



## 整合SpringMongodb实现文档操作

应用场景：浏览记录

### 引入依赖

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

### 配置文件

```yaml
spring:
	data:
        mongodb:
          database: mall-port
          host: localhost
          port: 27017
```

### 会员浏览记录文档对象MemberReadHistory

文档对象的ID域添加@Id注解，需要检索的字段添加@Indexed注解。

```java
import lombok.Data;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Document;

import java.util.Date;

/**
 * 用户商品浏览历史记录
 *
 * @author alienware
 * @date 2022/05/08
 */
@Data
@Document
public class MemberReadHistory {

    @Id
    private String id;
    @Indexed
    private Long memberId;
    private String memberNickname;
    private String memberIcon;
    @Indexed
    private Long productId;
    private String productName;
    private String productPic;
    private String productSubTitle;
    private String productPrice;
    private Date createTime;
}
```

### 添加MemberReadHistoryRepository接口用于操作Mongodb

继承MongoRepository接口，这样就拥有了一些基本的Mongodb数据操作方法，同时定义了一个衍生查询方法。

```java
/**
 * 会员商品浏览历史Repository
 *
 * @author alienware
 * @date 2022/05/08
 */
public interface MemberReadHistoryRepository extends MongoRepository<MemberReadHistory,String> {

    /**
     * 根据会员id按时间倒序获取浏览记录
     * @param memberId 会员id
     */
    List<MemberReadHistory> findByMemberIdOrderByCreateTimeDesc(Long memberId);
}
```

### 添加服务接口及其实现类

#### 服务接口MemberReadHistoryService

```java
/**
 * 会员浏览记录管理Service
 *
 * @author alienware
 * @date 2022/05/08
 */
public interface MemberReadHistoryService {
    /**
     * 生成浏览记录
     */
    int create(MemberReadHistory memberReadHistory);

    /**
     * 批量删除浏览记录
     */
    int delete(List<String> ids);

    /**
     * 获取用户浏览历史记录
     */
    List<MemberReadHistory> list(Long memberId);
}
```

#### 实现类MemberReadHistoryServiceImpl

```java
/**
 * 会员浏览记录管理Service实现类
 *
 * @author alienware
 * @date 2022/05/08
 */
@Service
public class MemberReadHistoryServiceImpl implements MemberReadHistoryService {
    @Autowired
    private MemberReadHistoryRepository memberReadHistoryRepository;

    @Override
    public int create(MemberReadHistory memberReadHistory) {
        memberReadHistory.setId(null);
        memberReadHistory.setCreateTime(new Date());
        memberReadHistoryRepository.save(memberReadHistory);
        return 1;
    }

    @Override
    public int delete(List<String> ids) {
        List<MemberReadHistory> deleteList = new ArrayList<>();
        for(String id:ids){
            MemberReadHistory memberReadHistory = new MemberReadHistory();
            memberReadHistory.setId(id);
            deleteList.add(memberReadHistory);
        }
        memberReadHistoryRepository.deleteAll(deleteList);
        return ids.size();
    }

    @Override
    public List<MemberReadHistory> list(Long memberId) {
        return memberReadHistoryRepository.findByMemberIdOrderByCreateTimeDesc(memberId);
    }
}
```

### 添加访问接口MemberReadHistoryController

```java
/**
 * 会员浏览记录管理Service实现类
 *
 * @author alienware
 * @date 2022/05/08
 */
@Service
public class MemberReadHistoryServiceImpl implements MemberReadHistoryService {
    @Autowired
    private MemberReadHistoryRepository memberReadHistoryRepository;

    @Override
    public int create(MemberReadHistory memberReadHistory) {
        memberReadHistory.setId(null);
        memberReadHistory.setCreateTime(new Date());
        memberReadHistoryRepository.save(memberReadHistory);
        return 1;
    }

    @Override
    public int delete(List<String> ids) {
        List<MemberReadHistory> deleteList = new ArrayList<>();
        for(String id:ids){
            MemberReadHistory memberReadHistory = new MemberReadHistory();
            memberReadHistory.setId(id);
            deleteList.add(memberReadHistory);
        }
        memberReadHistoryRepository.deleteAll(deleteList);
        return ids.size();
    }

    @Override
    public List<MemberReadHistory> list(Long memberId) {
        return memberReadHistoryRepository.findByMemberIdOrderByCreateTimeDesc(memberId);
    }
}
```



## 整合RabbitMQ实现延迟消息

### 业务场景

用于解决用户下单以后，取消超时订单的问题。

- 用户进行下单操作（会有锁定商品库存、使用优惠券、积分一系列的操作）；
- 生成订单，获取订单的id；
- 获取到设置的订单超时时间（假设设置的为60分钟不支付取消订单）；
- 按订单超时时间发送一个延迟消息给RabbitMQ，让它在订单超时后触发取消订单的操作；
- 如果用户没有支付，进行取消订单操作（释放锁定商品库存、返还优惠券、返回积分一系列操作）。

### 引入依赖

```xml
<!--消息队列相关依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
<!--lombok依赖-->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

### 配置文件

```yaml
spring:
    rabbitmq:
            host: localhost # rabbitmq的连接地址
            port: 5672 # rabbitmq的连接端口号
            virtual-host: /mall # rabbitmq的虚拟host
            username: mall # rabbitmq的用户名
            password: mall # rabbitmq的密码 #如果对异步消息需要回调必须设置为true
            publisher-confirm-type: correlated  # 如果对异步消息需要回调必须设置
```

根据上述配置，rabbitMQ需要提前配置：

- 用户账号：mall
- 虚拟host：/host  用户mall有该host的权限



### 配置消息队列枚举QueueEnum

用于消息队列的各种常量定义，包括交换机名称，队列名称

```java
/**
 * 消息队列枚举配置
 *
 * @author alienware
 * @date 2022/05/08
 */
@Getter
public enum QueueEnum {

    /**
     * 消息通知队列
     */
    QUEUE_ORDER_CANCEL("mall.order.direct", "mall.order.cancel", "mall.order.cancel"),
    /**
     * 消息通知ttl队列
     */
    QUEUE_TTL_ORDER_CANCEL("mall.order.direct.ttl", "mall.order.cancel.ttl", "mall.order.cancel.ttl");

    /**
     * 交换名称
     */
    private final String exchange;
    /**
     * 队列名称
     */
    private final String name;
    /**
     * 路由键
     */
    private final String routeKey;

    QueueEnum(String exchange, String name, String routeKey) {
        this.exchange = exchange;
        this.name = name;
        this.routeKey = routeKey;
    }
}
```

### 配置交换机/队列/绑定关系

#### 交换机/队列说明

- **mall.order.direct**：取消订单消息队列所绑定的交换机。绑定的队列为mall.order.cancel，一旦有消息以mall.order.cancel为路由键发过来，会发送到此队列。
- **mall.order.direct.ttl**：订单延迟消息队列所绑定的交换机。绑定的队列为mall.order.cancel.ttl，一旦有消息以mall.order.cancel.ttl为路由键发送过来，会转发到此队列，并在此队列保存一定时间，等到超时后会自动将消息发送到mall.order.cancel（取消订单消息消费队列）。

#### 交换机配置

```java
@Configuration
public class RabbitMqConfig {
    /**
     * 订单消息实际消费队列所绑定的交换机
     *
     * @return {@link DirectExchange}
     */
    @Bean
    DirectExchange orderDirect() {
        return ExchangeBuilder
                .directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange())
                .durable(true)
                .build();
    }

    /**
     * 订单延迟队列队列所绑定的交换机
     */
    @Bean
    DirectExchange orderTtlDirect() {
        return ExchangeBuilder
                .directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange())
                .durable(true)
                .build();
    }

    /**
     * 订单实际消费队列
     */
    @Bean
    public Queue orderQueue() {
        return new Queue(QueueEnum.QUEUE_ORDER_CANCEL.getName());
    }

    /**
     * 订单延迟队列（死信队列）
     */
    @Bean
    public Queue orderTtlQueue() {
        return QueueBuilder
                .durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getName())
                .withArgument("x-dead-letter-exchange", QueueEnum.QUEUE_ORDER_CANCEL.getExchange())//到期后转发的交换机
                .withArgument("x-dead-letter-routing-key", QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey())//到期后转发的路由键
                .build();
    }

    /**
     * 将订单队列绑定到交换机
     *
     * @param orderDirect 订单直接
     * @param orderQueue  命令队列
     * @return {@link Binding}
     */
    @Bean
    Binding orderBinding(DirectExchange orderDirect,Queue orderQueue){
        return BindingBuilder
                .bind(orderQueue)
                .to(orderDirect)
                .with(QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey());
    }

    /**
     * 将订单延迟队列绑定到交换机
     *
     * @param orderTtlDirect 订单ttl直接
     * @param orderTtlQueue  订单ttl队列
     * @return {@link Binding}
     */
    @Bean
    Binding orderTtlBinding(DirectExchange orderTtlDirect,Queue orderTtlQueue){
        return BindingBuilder
                .bind(orderTtlQueue)
                .to(orderTtlDirect)
                .with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey());
    }
}
```

### 添加延迟消息发送者CancelOrderSender

用于向订单延迟消息队列（mall.order.cancel.ttl）里发送消息。

```java
@Slf4j
@Component
public class CancelOrderSender {

    @Autowired
    private AmqpTemplate amqpTemplate;

    public void sendMessage(Long orderId, final long delayTimes) {
        //给延迟队列发送消息
        amqpTemplate.convertAndSend(
                QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange(),
                QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey(),
                orderId,
                message -> {
                    //  给消息设置延迟毫秒值
                    message.getMessageProperties().setExpiration(String.valueOf(delayTimes));
                    return message;
                });
        log.info("send delay message orderId:{}", orderId);
    }
}
```

### 添加取消订单服务

#### 提前准备好的参数类

##### OrderParam订单参数

```java
/**
 * 生成订单时传入的参数
 * Created by macro on 2018/8/30.
 */
@Data
public class OrderParam {
    /**
     * 收货地址ID
     */
    private Long memberReceiveAddressId;
    /**
     * 优惠券ID
     */
    private Long couponId;
    /**
     * 使用的积分数
     */
    private Integer useIntegration;
    /**
     * 支付方式
     */
    private Integer payType;
    /**
     * 被选中的购物车商品ID
     */
    private List<Long> cartIds;
}
```

#### 服务接口OmsPortalOrderService

```java
/**
 * 前台订单管理Service
 *
 * @author alienware
 * @date 2022/05/08
 */
public interface OmsPortalOrderService {

    /**
     * 根据提交信息生成订单
     */
    @Transactional
    CommonResult generateOrder(OrderParam orderParam);

    /**
     * 取消单个超时订单
     */
    @Transactional
    void cancelOrder(Long orderId);
}
```

#### 服务实现类OmsPortalOrderServiceImpl

```java
/**
 * 前台订单管理Service
 *
 * @author alienware
 * @date 2022/05/08
 */
@Slf4j
@Service
public class OmsPortalOrderServiceImpl implements OmsPortalOrderService {

    @Autowired
    private CancelOrderSender cancelOrderSender;

    @Override
    public CommonResult generateOrder(OrderParam orderParam) {
        //todo 执行一系类下单操作，具体参考mall项目
        log.info("process generateOrder");
        //下单完成后开启一个延迟消息，用于当用户没有付款时取消订单（orderId应该在下单后生成）
        sendDelayMessageCancelOrder(RandomUtil.randomLong());
        return CommonResult.success(null, "下单成功");
    }

    private void sendDelayMessageCancelOrder(Long orderId) {
        //  获取订单超时时间，这里设为30秒
        long delayTimes = 30 * 1000;
        //  发送延迟消息
        cancelOrderSender.sendMessage(orderId, delayTimes);
    }

    @Override
    public void cancelOrder(Long orderId) {
        //todo 执行一系类取消订单操作，具体参考mall项目
        log.info("process cancelOrder orderId:{}",orderId);
    }
}
```

### 添加取消订单消息接收者CancelOrderReceiver

用于从取消订单的消息队列（mall.order.cancel）里接收消息。

```java
/**
 * 取消订单消息的处理者
 *
 * @author alienware
 * @date 2022/05/09
 */
@Slf4j
@Component
@RabbitListener(queues = "mall.order.cancel")
public class CancelOrderReceiver {

    @Autowired
    private OmsPortalOrderService omsPortalOrderService;

    @RabbitHandler
    public void handle(Long orderId){
        log.info("receive delay message orderId:{}",orderId);
        omsPortalOrderService.cancelOrder(orderId);
    }
}
```



## 进一步整理权限设计

### 数据库设计

分为菜单与资源，菜单管理用于控制前端菜单显示，资源管理用于控制后端接口访问权限。

#### ums_admin

用户表，定义用户基本信息

```mysql
create table ums_admin
(
   id                   bigint not null auto_increment,
   username             varchar(64) comment '用户名',
   password             varchar(64) comment '密码',
   icon                 varchar(500) comment '头像',
   email                varchar(100) comment '邮箱',
   nick_name            varchar(200) comment '昵称',
   note                 varchar(500) comment '备注信息',
   create_time          datetime comment '创建时间',
   login_time           datetime comment '最后登录时间',
   status               int(1) default 1 comment '帐号启用状态：0->禁用；1->启用',
   primary key (id)
);
```

#### ums_role

角色表，定义角色基本信息，通过后台给用户分配角色，实现资源/菜单的分配

```mysql
create table ums_role
(
   id                   bigint not null auto_increment,
   name                 varchar(100) comment '名称',
   description          varchar(500) comment '描述',
   admin_count          int comment '后台用户数量',
   create_time          datetime comment '创建时间',
   status               int(1) default 1 comment '启用状态：0->禁用；1->启用',
   sort                 int default 0,
   primary key (id)
);
```

#### ums_admin_role_relation

用户角色关联表，多对多关系

```mysql
create table ums_admin_role_relation
(
   id                   bigint not null auto_increment,
   admin_id             bigint comment '用户id',
   role_id              bigint comment '角色id',
   primary key (id)
);
```

#### ums_menu

菜单表，控制访问菜单的显示，支持隐藏，排序，修改名称/图标

```mysql
create table ums_menu
(
   id                   bigint not null auto_increment,
   parent_id            bigint comment '父级ID',
   create_time          datetime comment '创建时间',
   title                varchar(100) comment '菜单名称',
   level                int(4) comment '菜单级数',
   sort                 int(4) comment '菜单排序',
   name                 varchar(100) comment '前端名称',
   icon                 varchar(200) comment '前端图标',
   hidden               int(1) comment '前端隐藏',
   primary key (id)
);
```

#### ums_resource

资源表，控制可以访问的接口，用了Ant路径的匹配规则，可以使用通配符定义一系列接口的权限。

```mysql
create table ums_resource
(
   id                   bigint not null auto_increment,
   category_id          bigint comment '资源分类ID',
   create_time          datetime comment '创建时间',
   name                 varchar(200) comment '资源名称',
   url                  varchar(200) comment '资源URL',
   description          varchar(500) comment '描述',
   primary key (id)
);
```

#### ums_resource_category

资源分类表，因为资源比较多而权限控制需要细粒度时，进行分类，便于角色分配资源。

```mysql
create table ums_resource_category
(
   id                   bigint not null auto_increment,
   create_time          datetime comment '创建时间',
   name                 varchar(200) comment '分类名称',
   sort                 int(4) comment '排序',
   primary key (id)
);
```

#### ums_role_menu_relation

角色菜单关联表，用于给角色分配前端菜单，多对多。

```mysql
create table ums_role_menu_relation
(
   id                   bigint not null auto_increment,
   role_id              bigint comment '角色ID',
   menu_id              bigint comment '菜单ID',
   primary key (id)
);
```

#### ums_role_resource_relation

角色资源关系表，多对多

```mysql
create table ums_role_resource_relation
(
   id                   bigint not null auto_increment,
   role_id              bigint comment '角色ID',
   resource_id          bigint comment '资源ID',
   primary key (id)
);
```





# mall-swarm

## 容器部署调整

### 调整内核参数以启动ES

作者提示需要配置系统内核参数，否则es会因为内存不足无法启动：

```sh
# 改变设置
sysctl -w vm.max_map_count=262144
# 使之立即生效
sysctl -p
```

**含义**

max_map_count包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量

```sh
# 查看系统当前配置量
sysctl -a|grep vm.max_map_count
```

**缺陷**

这种修改方式是临时配置，重启服务器后失效

**解决方案**

永久修改，需要修改配置文件

```sh
# 修改配置文件 
vim /etc/sysctl.conf
# 修改内容为
vm.max_map_count=262144
# 使之生效
sysctl -p
```



### Nginx文件额外映射

作者在配置文件设置了nginx.conf的映射

```conf
nginx:
    image: nginx:1.10
    container_name: nginx
    volumes:
      - /mydata/nginx/conf:/etc/nginx #配置文件挂载
      - /mydata/nginx/html:/usr/share/nginx/html #静态资源根目录挂载
      - /mydata/nginx/log:/var/log/nginx #日志文件挂载
    ports:
      - 80:80
```

并提供了一个nginx.conf文件，内容如下

```conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    server {
	    listen       80;
	    server_name  localhost;

	    location / {
	        root   /usr/share/nginx/html;
	        index  index.html index.htm;
	    }

	    error_page   500 502 503 504  /50x.html;
	    location = /50x.html {
	        root   /usr/share/nginx/html;
	    }
	}
}
```

**问题**

配置文件中需求一个mime.types文件，没有的话无法启动。

**解决方案**

- 配置文件中去掉`include       /etc/nginx/mime.types;`这部分内容

- 或者找到一个mime.types放在对应位置，即`/etc/nginx/mime.types`映射在主机的`/mydata/nginx/conf/mime.types`位置



### Portainer版本更新

作者提供的portainer容器启动指令：

```sh
docker pull portainer/portainer
docker run -p 9000:9000 -p 8000:8000 --name portainer \
--restart=always \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /mydata/portainer/data:/data \
-d portainer/portainer
```

不过启动后有提示显示版本有待更新，那就试一下吧

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220619012624399.png" alt="image-20220619012624399" style="zoom:67%;" />

运行指令，用portainer2.0版本的容器进行拉取

```sh
docker pull portainer/portainer-ce
# 注意处理容器重名问题
docker run -p 9000:9000 -p 8000:8000 --name portainer \
--restart=always \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /mydata/portainer/data:/data \
-d portainer/portainer-ce
```


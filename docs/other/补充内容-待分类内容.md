# 补充内容

## FastClass机制

[参考](https://www.daimajiaoliu.com/daima/485d9fc20900404)

FastClass顾名思义是一个能让被增强类更快调用的Class，主要针对调用方法是变量的场景，用于替代反射调用。

FastClass的实现逻辑，是生成增强类实现invoke方法，invoke方法中，用switch语义将被增强类的所有方法调用枚举出来。用户使用FastClass.invoke方法，传入方法index和被调用实例，从而达到不使用反射就能实现不确定方法的调用。

动态类为委托类方法调用语句建立索引，使用者根据方法签名（方法名+参数类型）得到索引值，再通过索引值进入相应的方法调用语句，得到调用结果。

省去了反射，提高了效率,实现了Java反射的“运行时动态调用指定类的方法”的功能，但是使用了不同的机制。

### 应用

CGLIB动态代理

### 代码

原方法，委托类

```java
public class DelegateClass {

    public DelegateClass() {
    }

    public DelegateClass(String string) {
    }

    public boolean add(String string, int i) {
        System.out.println("This is add method: " + string + ", " + i);
        return true;
    }

    public void update() {
        System.out.println("This is update method");
    }
}
```

FastClass

```java
public abstract class FastClass{

    // 委托类
    private Class type;
    
    // 子类访问构造方法
    protected FastClass() {}
    protected FastClass(Class type) {
        this.type = type;
    }
    
    // 创建动态FastClass子类
    public static FastClass create(Class type) {
        // Generator：子类生成器，继承AbstractClassGenerator
        Generator gen = new Generator();
        gen.setType(type);
        gen.setClassLoader(type.getClassLoader());
        return gen.create();
    }
    
    /**
     * 调用委托类方法
     *
     * @param name 方法名
     * @param parameterTypes 方法参数类型
     * @param obj 委托类实例
     * @param args 方法参数对象
     */
    public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) {
        return invoke(getIndex(name, parameterTypes), obj, args);
    }
    
    /**
     * 根据方法描述符找到方法索引
     *
     * @param name 方法名
     * @param parameterTypes 方法参数类型
     */
    public abstract int getIndex(String name, Class[] parameterTypes);
    
    
    /**
     * 根据方法索引调用委托类方法
     *
     * @param index 方法索引
     * @param obj 委托类实例
     * @param args 方法参数对象
     */
    public abstract Object invoke(int index, Object obj, Object[] args);
    
    /**
     * 调用委托类构造方法
     * 
     * @param parameterTypes 构造方法参数类型
     * @param args 构造方法参数对象
     */
    public Object newInstance(Class[] parameterTypes, Object[] args) throws {
        return newInstance(getIndex(parameterTypes), args);
    }
    
    /**
     * 根据构造方法描述符（参数类型）找到构造方法索引
     *
     * @param parameterTypes 构造方法参数类型
     */
    public abstract int getIndex(Class[] parameterTypes);
    
    /**
     * 根据构造方法索引调用委托类构造方法
     *
     * @param index 构造方法索引
     * @param args 构造方法参数对象
     */
    public abstract Object newInstance(int index, Object[] args);
    
}
```

FastClass子类

```java
public class DelegateClass$$FastClassByCGLIB$$4af5b667 extends FastClass {
    
    /**
     * 动态子类构造方法
     */
    public DelegateClass$$FastClassByCGLIB$$4af5b667(Class delegateClass) {
        super(delegateClass);
    }

    /**
     * 根据方法签名得到方法索引
     *
     * @param name 方法名
     * @param parameterTypes 方法参数类型
     */
    public int getIndex(String methodName, Class[] parameterTypes) {
        switch(methodName.hashCode()) {
            
            // 委托类方法add索引：0
            case 96417:
                if (methodName.equals("add")) {
                    switch(parameterTypes.length) {
                        case 2:
                            if (parameterTypes[0].getName().equals("java.lang.String") && 
                                parameterTypes[1].getName().equals("int")) {
                                return 0;
                            }
                    }
                }
                break;
            
            // 委托类方法update索引：1
            case -838846263:
                if (methodName.equals("update")) {
                    switch(parameterTypes.length) {
                        case 0:
                            return 1;
                    }
                }
                break;
                
            // Object方法equals索引：2
            case -1295482945:
                if (methodName.equals("equals")) {
                    switch(parameterTypes.length) {
                        case 1:
                            if (parameterTypes[0].getName().equals("java.lang.Object")) {
                                return 2;
                            }
                    }
                }
                break;
            
            // Object方法toString索引：3
            case -1776922004:
                if (methodName.equals("toString")) {
                    switch(parameterTypes.length) {
                        case 0: return 3;
                    }
                }
                break;
            
            // Object方法hashCode索引：4
            case 147696667:
                if (methodName.equals("hashCode")) {
                    switch(parameterTypes.length) {
                        case 0:
                            return 4;
                    }
                }
        }

        return -1;
    }
    
    /**
     * 根据方法索引调用委托类方法
     *
     * @param methodIndex 方法索引
     * @param delegateInstance 委托类实例
     * @param parameterValues 方法参数对象
     */
    public Object invoke(int methodIndex, Object delegateInstance, Object[] parameterValues) {
        DelegateClass instance = (DelegateClass) delegateInstance;
        int index = methodIndex;
        try {
            switch(index) {
                case 0:
                    // 委托类实例直接调用方法语句
                    return new Boolean(instance.add((String)parameterValues[0], 
                            ((Number)parameterValues[1]).intValue()));
                case 1:
                    instance.update();
                    return null;
                case 2:
                    return new Boolean(instance.equals(parameterValues[0]));
                case 3:
                    return instance.toString();
                case 4:
                    return new Integer(instance.hashCode());
            }
        } catch (Throwable t) {
            throw new InvocationTargetException(t);
        }

        throw new IllegalArgumentException("Cannot find matching method/constructor");
    }

    /**
     * 根据构造方法描述符（参数类型）找到构造方法索引
     *
     * @param parameterTypes 构造方法参数类型
     */
    public int getIndex(Class[] parameterTypes) {
        switch(parameterTypes.length) {
            // 无参构造方法索引：0
            case 0:
                return 0;
            
            // 有参构造方法索引：1
            case 1:
                if (parameterTypes[0].getName().equals("java.lang.String")) {
                    return 1;
                }
            default:
                return -1;
        }
    }
    
    /**
     * 根据构造方法索引调用委托类构造方法
     *
     * @param methodIndex 构造方法索引
     * @param parameterValues 构造方法参数对象
     */
    public Object newInstance(int methodIndex, Object[] parameterValues) {
        // 创建委托类实例
        DelegateClass newInstance = new DelegateClass;
        DelegateClass newObject = newInstance;
        int index = methodIndex;
        try {
            switch(index) {
                // 调用构造方法（<init>）
                case 0:
                    newObject.<init>();
                    return newInstance;
                case 1:
                    newObject.<init>((String)parameterValues[0]);
                    return newInstance;
            }
        } catch (Throwable t) {
            throw new InvocationTargetException(t);
        }

        throw new IllegalArgumentException("Cannot find matching method/constructor");
    }

    public int getMaxIndex() {
        return 4;
    }
}
```

### 总结

FastClass机制算是一种技巧层面的东西，在java内存里边维护一个index值和对象的方法之间的逻辑映射，然后运行期可以根据index和实例来动态调用方法、且不用使用比较“重”的Java反射功能。



## equals 与 == 的关系

- `==` 对于基本类型和引用类型的作用效果是不同的：

  - 对于基本数据类型来说，`==` 比较的是值。

  - 对于引用数据类型来说，`==` 比较的是对象的内存地址。

- `equals()` 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。

- `equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

- 类没有重写`equals()`方法时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。

- 类重写了 `equals()`方法时，一般重写来比较两个对象中的属性是否相等；

- `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

  > 当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。



### hashCode作用

- 获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。

- `hashCode()`定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。

- `Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

- 其实， `hashCode()` 和 `equals()`都是用于比较两个对象是否相等。

  > **为什么 JDK 还要同时提供这两个方法呢？**
  >
  > 这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高！
  >
  > 如添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同，也就是说 `hashCode` 帮助我们大大缩小了查找成本。

### 为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？

因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓**哈希碰撞**也就是指的是不同的对象得到相同的 `hashCode` )。

总结下来就是 ：

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。



### 为什么重写 equals() 时必须重写 hashCode() 方法？

因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

总结：

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。



## 代码块

- 普通代码块：在方法或语句中出现的{}，就被称为代码块

- 静态代码块：静态代码块有且仅加载一次，也就是在这个类被加载至内存的时候

- 普通代码块和一般语句执行顺序由他们在代码中出现的次序决定，先出现先执行。

- **构造代码块**比构造方法更高一级，会在每次创建对象时调用，并先于构造方法，随构造方法一起调用。

  ```java
  public class CodeBlock02 {
      {
          System.out.println("第二构造块33333");
      }
  
      public  CodeBlock02() {
          System.out.println("构造方法2222");
      }
  
      {
          System.out.println("第一构造块33333");
      }
  
      public static void main(String[] args) {
          new CodeBlock02();
          System.out.println("==========");
          new CodeBlock02();
      }
  }
  ```

  运行结果

  ```bash
  第二构造块33333
  第一构造块33333
  构造方法2222
  ==========
  第二构造块33333
  第一构造块33333
  构造方法2222
  ```

- **静态代码块**在类加载到内存时执行且只执行一次，并先于构造代码块。

- 静态代码块在类加载时必须执行。存在父子关系时，必须先加载父类，再加载子类。然后子类构造方法隐含super()优先调用父类构造方法。所以执行顺序是：

  父类静态代码块-子类静态代码块-父类构造代码块-父类构造方法-子类构造代码块-子类构造方法。

  ```java
  class Father {
      {
          System.out.println("我是父亲代码块");
      }
      public Father() {
          System.out.println("我是父亲构造");
      }
      static {
          System.out.println("我是父亲静态代码块");
      }
  }
  class Son extends Father{
      public Son() {
          System.out.println("我是儿子构造");
      }
      {
          System.out.println("我是儿子代码块");
      }
  
      static {
          System.out.println("我是儿子静态代码块");
      }
  }
  public class CodeBlock04 {
  
      public static void main(String[] args) {
  
          System.out.println("我是主类======");
          new Son();
          System.out.println("======");
          new Son();
          System.out.println("======");
          new Father();
      }
  }
  ```

  运行结果

  ```bash
  我是主类======
  我是父亲静态代码块
  我是儿子静态代码块
  我是父亲代码块
  我是父亲构造
  我是儿子代码块
  我是儿子构造
  ======
  我是父亲代码块
  我是父亲构造
  我是儿子代码块
  我是儿子构造
  ======
  我是父亲代码块
  我是父亲构造
  ```



## 深拷贝与浅拷贝

### 结论

- **浅拷贝**：在堆上创建一个新的对象，如果原对象内部属性有引用类型，则复制内部对象的引用地址。也就是说拷贝对象与原对象公用内部引用类型成员变量。
- **深拷贝**：完全复制一个对象，包含这个对象包含的内部对象。



### 浅拷贝

实现 `Cloneable` 接口，并重写 `clone()` 方法，直接调用的是父类 `Object` 的 `clone()` 方法。

```java
public class Address implements Cloneable{
    private String name;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Address clone() {
        try {
            return (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

public class Person implements Cloneable {
    private Address address;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Person clone() {
        try {
            Person person = (Person) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

如上 Person类包含一个Address属性，这个时候调用Person的clone方法：

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// true
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

此时person1Copy与person1的address属性是同一个对象。



### 深拷贝

手动重写`Person` 类的 `clone()` 方法，让`Person` 对象内部的 `Address` 对象一起复制。

```java
@Override
public Person clone() {
    try {
        Person person = (Person) super.clone();
        person.setAddress(person.getAddress().clone());
        return person;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

这个时候调用Person的clone方法：

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// false
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

此时person1Copy与person1的address属性不是同一个对象。



### 引用拷贝

两个不同的引用指向同一个对象。





## 分布式锁



### 集群环境下保证ID不重复

原来的Synchronized + Lock只能锁单机，也就是只能在一个JVM环境下;

而在分布式+集群的环境下，变成了N对N的关系，在并发的环境下，如果使用UUID或者自增ID，就可能出现ID重复的问题，因此在集群下的环境下，对JVM进行加锁，这就是分布式锁。

在小厂的解决方案：也就是QPS（每秒查询数/吞吐量） < 2000的公司，有以下三种方案

- mysql数据库的乐观锁实现
- redis：redission
- zookeeper：（服务治理 和 服务注册）



### 单机环境下的锁

场景：订单服务OrderService的getOrderNumber生成订单号，在并发情况下可能生成重复的情况。

#### 原代码

```java
public class OrderNumberCreateUtil {
    private static int num = 0;

    public String getOrderNumber() {
        return "\t 生成订单号：" + (++num);
    }

}
public class OrderService {
    private OrderNumberCreateUtil orderNumberCreateUtil = new OrderNumberCreateUtil();

    public String getOrderNumber() {
        return orderNumberCreateUtil.getOrderNumber();
    }
}
```

客户端并发50个线程生成订单号

```java
public class Client {
    public static void main(String[] args) {
        OrderService orderService = new OrderService();

        for (int i = 0; i < 50; i++) {
            new Thread(() -> {
                String str = orderService.getOrderNumber();
                System.out.println(str);
            }, String.valueOf(i)).start();
        }
    }
}
```

结果

```shell
生成订单号：1
生成订单号：3
生成订单号：2
生成订单号：4
生成订单号：5
生成订单号：1
生成订单号：6
生成订单号：7
生成订单号：8
生成订单号：9
生成订单号：10
生成订单号：11
生成订单号：12
生成订单号：13
生成订单号：14
生成订单号：15
...
```



#### 单机加锁

解决方案是，在Service层调用生成订单号的时候，加锁保证同一时间只能有一个线程调用这个订单号生成，从而保证num正常递增。

```java
 //lock 应该申明为类的成员变量
private Lock lock = new ReentrantLock();
public String getOrderNumber() {
    lock.lock();
    try {
        return orderNumberCreateUtil.getOrderNumber();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
    return null;
}
```



### Zookeeper实现分布式锁

因为Zookeeper在创建节点的时候，需要保证节点的唯一性，也就是实现原理就是，每次一个线程获取到了锁，那就在Zookeeper上创建一个临时节点，但用完锁之后，再把这个节点删除掉

```
create /node v0410  # 创建一个持久节点
crate -e /node v0410 # 创建一个临时节点
```

对于单进程的并发场景，我们可以使用synchronized关键字和Reentrantlock等

对于 分布式场景，我们可以使用分布式锁。

#### 创建锁

多个JVM服务器之间，同时在zookeeper上创建相同一个临时节点，因为临时节点路径是保证唯一，只要谁能创建节点成功，谁就能获取到锁。

没有创建成功节点，只能注册个监听器监听这个锁并进行等待，当释放锁的时候，采用事件通知给其它客户端重新获取锁的资源。

这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入获取锁的步骤。

#### 释放锁

Zookeeper使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭，该临时节点也会被删除，这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入到获取锁的步骤。



#### 模板模式

##### 概念

在模板模式（Template Pattern）设计模式中，用一个抽象类公开定义了执行它的方法的方式、模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行

意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构，即可重定义该算法的某些特定步骤：

主要解决：一些方法通用，却在每个子类都重新写了这一方法

何时使用：在一些通用的方法

如何解决：将这些通用算法抽象出来

关键代码：在抽象父类中实现通用方法，其它步骤下放到子类中实现

##### 应用

- spring中对Hibernate的支持，将一些定好的方法封装起来，比如开启事务，获取Session，关闭Session，程序要不需要重复写那些已经规范好的代码，直接丢一个实体就可以保存。

##### 优缺点

###### 优点

- 封装不变部分，扩展可变部分
- 提取公共代码，便于维护
- 行为由父类控制，子类实现

###### 缺点

- 每一个不同的实现，都需要一个子类来实现，导致类的个数增加，使得系统变庞大

##### 使用场景

- 有很多子类共有的方法，且逻辑相同
- 重要的、复杂的方法，可以考虑模板方法



#### 代码实现

利用模板模式创建一个分布式锁类

```java
//	定义一个zkLock的接口 定义两个方法，zkLock上锁/zkUnlock释放锁
public interface ZkLock {

    public void zkLock();

    public void zkUnlock();
}
//	抽象类中继承该接口，同时实现 zkLock 和 zkUnLock 的方法（模板方法模式）
//	同时我们在抽象类里，又定义了两个抽象方法，zkWaitLock等待锁 和 tryLock尝试获得锁
public abstract class ZkAbstractTemplateLock implements ZkLock{

    @Override
    public void zkLock() {
        // 尝试获取锁
        if(tryLock()) {
            System.out.println(Thread.currentThread().getName() + "\t 占用锁成功");
        } else {
            // 等待锁
            waitZkLock();
            // 重新调用获取锁的方法
            zkLock();
        }
    }

    /**
     * 定义两个抽象方法，一个是尝试锁，一个是等待锁
     * @return
     */
    public abstract boolean tryLock();

    public abstract void waitZkLock();

    @Override
    public void zkUnlock() {

    }
}
//	后续是定义实体类继承抽象类，实现 等待锁 和 尝试获得锁，这个类就是一个分布式锁
public class ZkDistributedLock extends ZkAbstractTemplateLock{
    @Override
    public boolean tryLock() {
        // 判断节点是否存在，如果存在则返回false，否者返回true
        return false;
    }

    @Override
    public void waitZkLock() throws InterruptedException {
        // 等待锁的时候，需要加监控，查询这个lock是否释放

        CountDownLatch countDownLatch = new CountDownLatch(1);

        countDownLatch.await();

        // 解除监听
    }
}
```

用这个分布式锁对获取订单号进行上锁

```java
public class OrderService {
    private OrderNumberCreateUtil orderNumberCreateUtil = new OrderNumberCreateUtil();

    public void getOrderNumber() {
        ZkLock zkLock = new ZkDistributedLock();
        zkLock.zkLock();
        try {

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            zkLock.zkUnlock();
        }
        System.out.println(orderNumberCreateUtil.getOrderNumber());
    }
}
```



## 前后端分离项目解决跨域问题

### 跨域

跨域资源共享([CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)) 是一种机制，它使用额外的 [HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 头来告诉浏览器，让一个 运行在origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。

当一个资源从与该资源本身所在的服务器**不同的域、协议或端口**请求一个资源时，资源会发起一个**跨域 HTTP 请求**。

出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。

### CORS头

| 内容                                                         | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [`Access-Control-Allow-Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) | 指示请求的资源能共享给哪些域。                               |
| [`Access-Control-Allow-Credentials`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials) | 指示当请求的凭证标记为 true 时，是否响应该请求。             |
| [`Access-Control-Allow-Headers`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers) | 用在对预请求的响应中，指示实际的请求中可以使用哪些 HTTP 头。 |
| [`Access-Control-Allow-Methods`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods) | 指定对预请求的响应中，哪些 HTTP 方法允许访问请求的资源。     |
| [`Access-Control-Expose-Headers`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers) | 指示哪些 HTTP 头的名称能在响应中列出。                       |
| [`Access-Control-Max-Age`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age) | 指示预请求的结果能被缓存多久。                               |
| [`Access-Control-Request-Headers`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers) | 用于发起一个预请求，告知服务器正式请求会使用那些 HTTP 头。   |
| [`Access-Control-Request-Method`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method) | 用于发起一个预请求，告知服务器正式请求会使用哪一种 [HTTP 请求方法](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)。 |
| [`Origin`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin) | 指示获取资源的请求是从什么域发起的。                         |



### Spring跨域校验

Spring 中对 CORS 规则的校验，都是通过委托给 DefaultCorsProcessor实现的。

DefaultCorsProcessor 处理过程如下：

1. 判断依据是 Header中是否包含 Origin。如果包含则说明为 CORS请求，转到 2；否则，说明不是 CORS 请求，不作任何处理。

2. 判断 response 的 Header 是否已经包含 Access-Control-Allow-Origin，如果包含，证明已经被处理过了, 转到 3，否则不再处理。

3. 判断是否同源，

   - 如果是则转交给负责该请求的类处理；

   - 如果不是则检查是否配置了 CORS 规则

     - 如果没有配置，且是预检请求，则拒绝该请求；

     - 如果没有配置，且不是预检请求，则交给负责该请求的类处理；

     - 如果配置了，则对该请求进行校验。 校验就是根据 CorsConfiguration 这个类的配置进行判断：

       - 判断 origin 是否合法
       - 判断 method 是否合法
       - 判断 header是否合法

       如果全部合法，则在 response header中添加响应的字段，并交给负责该请求的类处理，如果不合法，则拒绝该请求。



### 解决方案

#### 实现WebMvcConfigurer接口

```java
@Bean
public WebMvcConfigurer corsConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            //配置允许跨域访问的路径
            registry.addMapping("/**/**")
                .allowedOrigins("*")
                .allowedMethods("*")
                .allowedHeaders("*")
                .allowCredentials(true)
                .exposedHeaders("")
                .maxAge(3600);
        }
    };
}
```

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    /**
     * 跨域支持
     * @param registry
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowCredentials(true)
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                .maxAge(3600 * 24);
    }

}
```

#### 覆盖默认的CorsFilter

```java
@Bean
public CorsFilter corsFilter() {
    CorsConfiguration config = new CorsConfiguration();
    //允许所有域名进行跨域调用
    config.addAllowedOrigin("*");
    //允许跨越发送cookie
    config.setAllowCredentials(true);
    //放行全部原始头信息
    config.addAllowedHeader("*");
    //允许所有请求方法跨域调用
    config.addAllowedMethod("*");
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);
    return new CorsFilter(source);
}
```





### 刷新token时将token通过cookie传递的跨域问题

存在这样的需求，就是token即将过期时需要进行刷新，后台通过cookie将新的token传给前端。

前端axios需要配置 withCredentials=true 才能接收到后端传递的结果：

```javascript
// 创建axios实例
const service = axios.create({
  baseURL: '', // api 的 base_url
  withCredentials: true, //允许后台的cookie传递到前端
  timeout: 100000 // 请求超时时间
})
```

> #### XMLHttpRequest 的 withCredentials 属性
>
> - 默认值为false。在获取同域资源时设置 withCredentials 没有影响。
> - true：在跨域请求时，会携带用户凭证
> - false：在跨域请求时，不会携带用户凭证；返回的 response 里也会忽略 cookie

存在后端用这种方式配置跨域：

```java
private CorsConfiguration buildConfig() {
    CorsConfiguration corsConfiguration = new CorsConfiguration();
    corsConfiguration.addAllowedOrigin("*");
    corsConfiguration.addAllowedHeader("*");
    corsConfiguration.addAllowedMethod("*");
    return corsConfiguration;
}

/**
  * 跨域过滤器
  *
  * @return
  */
@Bean
public CorsFilter corsFilter() {
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", buildConfig());
    return new CorsFilter(source);
}
```

会产生跨域错误，使token无法通过cookie传递。

![image-20200612152510503](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20200612152510503.png)

而用上面的解决方案是可以传递的。



### 图片跨域

静态资源的访问选择通过nginx代理直接访问，则此时跨域配置需要在nginx进行配置。

方式是在对应静态资源配置添加如下：

```nginx
add_header Access-Control-Allow-Origin *;
add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,lang,access-token';
if ($request_method = 'OPTIONS') {
    return 204;
}
```

含义就是添加了三个请求头，以及一个请求方式判定。



## AQS（抽象队列同步器）的理解

AQS：AbstractQueuedSynchronizer 抽象队列同步器

AQS是一个抽象类，是我们用到的锁的基础，例如我们经常用到的

- ReentrantLock
- Semaphore
- CountdownLatch
- ReentrantReadWriteLock
- .....

> 不熟悉 暂时搁置  http://note.moguit.cn/#/./Java/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AQS%E7%9A%84%E7%90%86%E8%A7%A3/README



## JWT

JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的。

### 组成

- JWT token的格式：header.payload.signature

- header中用于存放签名的生成算法

  ```json
  {"alg": "HS512"}
  ```

- payload中用于存放用户名、token的生成时间和过期时间

  ```json
  {"sub":"admin","created":1489079981393,"exp":1489684781}
  ```

- signature为以header和payload生成的签名，一旦header和payload被篡改，验证将失败

  ```java
  //secret为加密算法的密钥
  String signature = HMACSHA512(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)
  ```



### 实例

在该网站上获得解析结果：https://jwt.io/

如：

```sh
eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBw
```

![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/arch_screen_13.fc3ff0ff.png)



### 实现认证和授权的原理

- 用户调用登录接口，登录成功后获取到JWT的token；
- 之后用户每次调用接口都在http的header中添加一个叫Authorization的头，值为JWT的token；
- 后台程序通过对Authorization头中信息的解码及数字签名校验来获取其中的用户信息，从而实现认证和授权。



## Ant风格

就是一种**路径匹配表达式**。主要用来对`uri`的匹配。其实跟正则表达式作用是一样的，只不过正则表达式适用面更加宽泛，`Ant`仅仅用于路径匹配。

### Ant通配符

| 通配符 | 含义                                   |
| ------ | -------------------------------------- |
| ？     | 匹配单字符                             |
| \*     | 匹配零个或任意数量个字符               |
| \**    | 匹配零层或任意层目录路径，等价\*/*/... |

> 单个`*` 是在一个目录内进行匹配。 而`**` 是可以匹配多个目录。

### 应用

| 路径           |                                                    |
| -------------- | -------------------------------------------------- |
| /mapper/\*.xml | 匹配mapper目录下的所有xml文件                      |
| /page/size?    | 匹配/page/size1和/page/sizeM，不匹配/page/size     |
| /\**/a.xml     | 匹配任意目录下的a.xml文件                          |
| /src/file.\*   | 匹配src目录下所有file文件，如file.java，file.class |
| /\**/\*.java   | 匹配任意目录的java文件                             |

### 最长匹配原则

一旦一个`uri` 同时符合两个`Ant`匹配那么走匹配规则字符最多的。

为什么走最长？因为字符越长信息越多就越具体。

如/mapper/pms/product.xml，对应两个/\**/\*.xml和/mapper/pms/\*.xml两个路径匹配，最后会匹配到第二个。


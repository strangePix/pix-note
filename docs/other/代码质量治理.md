# 代码质量治理

[参考](https://www.codenong.com/cs105878703/)

## 背景

### 代码质量下降的恶性循环

代码质量下降通常会自成因果，导致恶性循环：

- **破窗效应**

  在烂代码上继续生产烂代码的心理负担小很多。

- **传染性**

  烂代码传递着一种不在意质量，只看业务成果的负面信息，会伤害团队的技术热情和工作氛围，导致更多烂代码出现。



## 代码质量定义

代码质量的评判好坏有很强的主观性，这里以权威为参考。

> ​		我喜欢优雅和高效的代码，代码逻辑应该直截了当，叫缺陷难以掩藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省的别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。
> – Bjarne Stroustrup，C++语言之父 《C++程序设计语言》作者

> ​		整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从来不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。
> – Grady Booch，《面向对象分析与设计》作者

总结：

- 直截了当：便于阅读和理解
- 方便维护和扩展
- 逻辑清晰和直接
- 设计优良，性能优异，没有隐藏BUG



## 代码质量标准

代码质量的评价很主观，不太容易通过一套量化指标评定，不同的标准使用的范围和场景并不相同。

所以首先要基于团队共识形成一套适用于**团队内部**的标准，降低个人的主观性，也避免指标生搬硬套导致无效产出。

### 团队情况分析

首先要了解自己的团队，一般从人、事、维度分析，以原文作者的分析参考：

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211028233.png" alt="在这里插入图片描述" style="zoom: 80%;" />

- 团队成员多种技术背景：多种技术栈导致代码风格差异不统一，容易将其他语言风格带入开发，需要整理统一编码规范。
- toB业务用户规模小，业务流程复杂：更多关注程序健壮性，而非并发用户量指标。



### 基于团队分析的衡量质量模型

基于团队分析，生成第一版衡量代码质量模型，基于指标进行针对性治理，并通过实践发现问题，进行完善。

![在这里插入图片描述](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211033508.png)

### 依据模型确定指标

- 编码规范
- 圈复杂度
- 重复率
- 最佳实践
- 覆盖率
- 响应时间
- 资源利用率
- 漏洞数
- 错误数



## 代码质量治理动机

### 反向后果

- 代码阅读困难，维护成本高
- 研发效率降低
- 容易出现bug，隐藏安全漏洞
- 代码性能下降
- 大规模重构费时费力

### 实践难点

1. 同步性难以保证：团队拉齐代码质量意识较难，每个人自己的个性，喜欢按自己舒服的方式工作。
2. 开发时间紧张：公司崇尚敏捷开发，迭代周期较短，领导关心任务的完成而非代码质量。
3. 成果难以量化：代码质量短时间没有明显的观感差异，到达临界点后才会暴露问题，会造成这项工作无法快速获得立竿见影的正向反馈，降低这项工作的动力。



## 代码质量落地策略



### 专项治理

针对代码中的顽疾进行专项治理。

首先要识别出当前代码有哪些痛点，而识别痛点可以使用经典的指标：WTF/min。

> **WTF/min**
>
> WTF就是 what the fuck的缩写， WTF/min就是每分钟说出 what the fuck的次数，简单来讲就是当某个人在看一份代码时每分钟爆粗口的次数。
>
> 显然每分钟爆粗口的次数越多代码质量越差，反之越好。

专项治理因为目标明确，选择好方案执行即可。

#### 专项治理方向

- maven依赖治理
- 日志治理
- 代码重构
- ...



### 流程卡点

在研发流程中设置卡点来保证每次迭代代码的质量。

需要使用一系列的工具作为抓手，层层递进来保障代码的质量。

#### 代码管控的四个阶段

- **规范化**  制定代码规范
- **自动化**  借助工具保证规范落地
- **流程化**  在流程中设置质量检查卡点，避免漏网之鱼
- **中心化**  以团队整体为视角，集中管理代码规范，实现质量状况透明

#### 规范化

保证代码质量的第一步是建立团队代码规范，让大家能够形成共识，才能知道怎么做。

在落实规范这件事上，可以选择站在巨人的肩膀上，然后再加入团队特有的一些共识制定一套适用自己的规范准则。

- **风格规范**  选择 [Google Style Guides](https://github.com/google/styleguide) 
- **编码规范**  选择 [阿里巴巴Java开发手册](https://github.com/alibaba/p3c)
- 通过CodeReview机制沉淀团队内部规范

#### 自动化

代码规范制定好后怎样能保证每个人都能按照规范编写代码，如果只靠个人自觉性那是不靠谱的，必须要有工具来做支撑，没有通过工具检测的代码就不能被提交到仓库。

- **代码自动格式化工具**  [SavaActions](https://plugins.jetbrains.com/plugin/7642-save-actions/versions)
- **编码规范检测工具**  [P3C](https://github.com/alibaba/p3c)
- **代码质量检测工具**  [SonarLint](https://plugins.jetbrains.com/plugin/7973-sonarlint)
- **单元测试覆盖率工具 ** [JaCoCo](https://www.jacoco.org/jacoco/)

#### 流程化

[参考](https://www.cnblogs.com/duanxz/p/4957991.html)

工具可以帮助我们高效的实现代码规范的落地，但是没有制度和流程的约束，随着时间的推移代码质量意识在团队中慢慢就会被淡化，最终又会回到初始的混沌状态，所以我们必须在制度和流程上强制采取质量保证措施。

![在这里插入图片描述](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207220054890.png)

#### 中心化

当公司规模较大时，往往会划分为很多个小团队，每个小团队很可能各自为政，这时就很难从细节上去保证规范的落实。

并且每个小团队适用的规范也不尽相同，不能用一套标准去要求所有人，到这个阶段更多的关注点应该放在方法论的输出上，而非具体的执行细节。

具体的执行细节可以让各个团队自己去实施，但是需要有一套统一的评分标准来评估每个团队的实施状况。

![image-20220722005523697](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207220055767.png)

### 打造团队文化

有的工具和流程制度都属于代码质量治理的外部力量，只有培养团队的质量文化才能最大限度的统一团队意志，自驱性的保证代码质量，这才是最高效率的方式。

怎样才能打造好自己团队的文化，是值得每个人去思考的话题。可以关注的方面：

- **CodeReview文化**  CR是一种很好的学习和总结方式，也是团队交流技术的一个很好的渠道。
- **Owner责任制文化**  owner意识可以让团队成员摆脱事不关己高高挂起的状态，通过将每个工程设定owner，可以让每个人主动去推动自己所负责的项目的质量，这可以更好的培养大家的质量意识。
- **技术分享文化**  通过“学习吸收率金字塔”可知，教授他人是吸收率最高的一种方式，通过技术分享可以培养团队的技术氛围，一个技术氛围好的团队，才会有更多的技术交流，也才会更加注重代码质量。
- **沉淀团队知识库**  团队要将一些好的案例和最佳实践以文本的形式沉淀下来，这样能方便后来者快速了解相关知识，避免走弯路，同时推动团队成员都以最佳实践来写代码，也是保证代码质量强有力的保证。







## 部分指标概念解释



### 圈复杂度(Cyclomatic complexity，CC)

[参考](http://kaelzhang81.github.io/2017/06/18/%E8%AF%A6%E8%A7%A3%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/)

#### 概念

- 也称为条件复杂度，是一种衡量代码复杂度的标准。

- 由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，用来表示程序的复杂度，其符号为VG或是M。

- 可以用来衡量一个模块判定结构的复杂程度，其数量上表现为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。
- 圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。



#### 计算方法

##### 点边计算法

![name basic flow graph](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211149385.jpeg)

计算公式为：

```shell
V(G) = E - N + 2
# E表示控制流图中边的数量，N表示控制流图中节点的数量。
```

> - n 代表在控制流图中的节点数量，包括起点 和终点
> - 节点对应代码中的分支语句
> - 所有终点只计算一次，即便有多个return或者throw

下图时典型控制流程，如if-else，While，until和正常的流程顺序图。

![name basic flow graph](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211150284.png)





##### 节点判定法

更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1，也即控制流图的区域数。

```shell
V (G) = P + 1
# 其中P为判定节点数。
```

> **判定节点**
>
> 判定节点举例：
>
> - if语句
> - while语句
> - for语句
> - case语句
> - catch语句
> - and和or布尔操作
> - ?:三元运算符
>
> 多分支case结构或者if-else if-else结构，统计判定节点的个数要求为全部实际的判定节点数。
>
> 即每个else if以及每个case都算作一个判定节点。



##### 计算方式的选择

判定节点在模块的控制流图中很容易被识别出来，所以：

- 针对程序的控制流图计算圈复杂度V(G)时，一般采用点边计算法，也即V(G)=e-n+2；
- 针对模块的控制流图时，可以直接使用统计判定节点数，这样更为简单。



#### 圈复杂度和软件质量

| 圈复杂度 | 代码状况     | 可测性 | 维护成本 |
| :------- | :----------- | :----- | :------- |
| 1-10     | 清晰、结构化 | 高     | 低       |
| 10-20    | 复杂         | 中     | 中       |
| 20-30    | 非常复杂     | 低     | 高       |
| >30      | 不可读       | 不可测 | 非常高   |



#### 如何降低圈复杂度

##### 重新组织函数

- **提炼函数**

  有一段代码可以被组织在一起并独立出来，则将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

  最后还要重新审视函数内容是否在统一层次上。

- **替换算法**

  把一个算法用更清晰的算法进行替换。

  ```java
  for (People people : peoples) {
      if (people == "Don"){
          return "Don";
      }
      if (people == "John"){
          return "John";
      }
      if (people == "Kent"){
          return "Kent";
      }
  }
  return "";
  ```

  ```java
  private static HashMap<String,String> peopleMap = new HashMap<>();
  static {
      peopleMap.put("Don","Don");
      peopleMap.put("John","John");
      peopleMap.put("Kent","Kent");
  }
  for (People people : peoples) {
      return Optional.ofNullable(peopleMap.get(people)).orElse("");
  }
  ```

##### 简化条件表达式

- **逆向表达**

  如原有的条件表达式很复杂，且他的取反条件比较简单，可以考虑改为反向判断。

  ```java
  //	如果条件1且条件2 或者非条件1
  if((condition1() && condition2()) || !condition1()){
      return 1;
  }
  return 0;
  ```

  ```java
  //	反过来就是 如果条件1且非条件2
  if(condition1() && !condition2()){
      return 0;
  }
  return 1;
  ```

- **分解条件**

  条件表达式以及各自的执行体比较大时，可以分别拆分为独立函数。

  ```java
  if(a < b || b < c || c < d){
      a+=b;b+=c;c+=d;
  }else{
      c+=d;b+=c;a+=b;
  }
  ```

  ```java
  // 三个表达式分别提取为单独的方法
  if(test(a,b,c)){
      method1(a,b,c);
  }else{
      method2(a,b,c);
  }
  ```

- **合并条件**

  如果一系列条件判断得到的结果相同，则将判断合并为一个条件，并将这个条件提炼为独立函数。

  ```java
  if (a < 2) return 0;
  if (b > 12) return 0;
  if (c) return 0;
  ```

  ```java
  public boolean test(a,b,c){
     return a < 2 || b > 12 || c; 
  }
  if(test(a,b,c))return 0;
  ```

- **移除控制印记**

  代码逻辑中有时会用布尔值作为逻辑控制标记，可以使用break和return取代这种标记。

  ```java
  boolean test = false;
  for(People people:peoples){
      if(!test){
          if(people == "a"){
              doSomeThing();
              test = true;
          }
      }
  }
  ```

  ```java
  for(People people:peoples){
      if(people == "a"){
          doSomeThing();
          break;
      }
  }
  ```

- **多态取代条件式**

  条件式根据对象类型选择不同行为的，将条件式的每个分支放入子类的重载方法，将原函数声明为抽象方法。

  ```java
  switch(a.getType()){
      case A:
          return doA();
      case B:
          return doB();
  }
  throw new RuntimeException ("Should be unreachable");
  ```

  ```java
  interface TotalClass{
      String getType();
      void do();
  }
  class ClassA implements TotalClass{
      String getType(){return "A"};
      void do(){doA();};
      private void doA();
  }
  class ClassB implements TotalClass{
      String getType(){return "B"};
      void do(){doB();};
      private void doB();
  }
  
  TotalClass caseClass = new ClassA();
  caseClass.do();
  ```



##### 简化函数调用

- **读写分离**

  某个函数既读取对象状态值，也能修改对象状态。将其拆分为两个函数，一个负责读取，一个负责查询。

- **参数化方法**

  若干函数执行类似工作，只是使用的值有区别。将其整合成一个函数，根据传值不同执行相同操作。

- **用明确函数取代参数**

  如函数实现根据参数值做出不同操作，可以将每个参数的操作拆分为一个独立方法。

  ```java
  void setValue(String column,Integer value){
      if(column == "A"){
          a = value;
      }
      if(column == "B"){
          b = value;
      }
  }
  ```

  ```java
  void setA(Integer value){
      a = value;
  }
  void setB(Integer value){
      b = value;
  }
  ```

  

#### 圈复杂度工具

- **IDEA圈复杂度插件MetricsReload**

  ![在这里插入图片描述](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211333745.png)
# 代码质量治理

[参考](https://www.codenong.com/cs105878703/)



## 代码质量定义

代码质量的评判好坏有很强的主观性，这里以权威为参考。

> ​		我喜欢优雅和高效的代码，代码逻辑应该直截了当，叫缺陷难以掩藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省的别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。
> – Bjarne Stroustrup，C++语言之父 《C++程序设计语言》作者

> ​		整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从来不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。
> – Grady Booch，《面向对象分析与设计》作者

总结：

- 直截了当：便于阅读和理解
- 方便维护和扩展
- 逻辑清晰和直接
- 设计优良，性能优异，没有隐藏BUG



## 代码质量标准

代码质量的评价很主观，不太容易通过一套量化指标评定，不同的标准使用的范围和场景并不相同。

所以首先要基于团队共识形成一套适用于**团队内部**的标准，降低个人的主观性，也避免指标生搬硬套导致无效产出。

### 团队情况分析

首先要了解自己的团队，一般从人、事、维度分析，以原文作者的分析参考：

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211028233.png" alt="在这里插入图片描述" style="zoom: 80%;" />

- 团队成员多种技术背景：多种技术栈导致代码风格差异不统一，容易将其他语言风格带入开发，需要整理统一编码规范。
- toB业务用户规模小，业务流程复杂：更多关注程序健壮性，而非并发用户量指标。



### 基于团队分析的衡量质量模型

基于团队分析，生成第一版衡量代码质量模型，基于指标进行针对性治理，并通过实践发现问题，进行完善。

![在这里插入图片描述](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211033508.png)

### 依据模型确定指标

- 编码规范
- 圈复杂度
- 重复率
- 最佳实践
- 覆盖率
- 响应时间
- 资源利用率
- 漏洞数
- 错误数



## 代码质量治理动机

### 反向后果

- 代码阅读困难，维护成本高
- 研发效率降低
- 容易出现bug，隐藏安全漏洞
- 代码性能下降
- 大规模重构费时费力

### 实践难点

1. 同步性难以保证：团队拉齐代码质量意识较难，每个人自己的个性，喜欢按自己舒服的方式工作。
2. 开发时间紧张：公司崇尚敏捷开发，迭代周期较短，领导关心任务的完成而非代码质量。
3. 成果难以量化：代码质量短时间没有明显的观感差异，到达临界点后才会暴露问题，会造成这项工作无法快速获得立竿见影的正向反馈，降低这项工作的动力。



## 代码质量落地策略（待补充）









## 部分指标概念解释



### 圈复杂度(Cyclomatic complexity，CC)

[参考](http://kaelzhang81.github.io/2017/06/18/%E8%AF%A6%E8%A7%A3%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6/)

#### 概念

- 也称为条件复杂度，是一种衡量代码复杂度的标准。

- 由托马斯·J·麦凯布（Thomas J. McCabe, Sr.）于1976年提出，用来表示程序的复杂度，其符号为VG或是M。

- 可以用来衡量一个模块判定结构的复杂程度，其数量上表现为独立路径的条数，也可理解为覆盖所有的可能情况最少使用的测试用例个数。
- 圈复杂度大说明程序代码的判断逻辑复杂，可能质量低且难于测试和维护。程序的可能错误和高的圈复杂度有着很大关系。



#### 计算方法

##### 点边计算法

![name basic flow graph](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211149385.jpeg)

计算公式为：

```shell
V(G) = E - N + 2
# E表示控制流图中边的数量，N表示控制流图中节点的数量。
```

> - n 代表在控制流图中的节点数量，包括起点 和终点
> - 节点对应代码中的分支语句
> - 所有终点只计算一次，即便有多个return或者throw

下图时典型控制流程，如if-else，While，until和正常的流程顺序图。

![name basic flow graph](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211150284.png)





##### 节点判定法

更直观的方法，因为圈复杂度所反映的是“判定条件”的数量，所以圈复杂度实际上就是等于判定节点的数量再加上1，也即控制流图的区域数。

```shell
V (G) = P + 1
# 其中P为判定节点数。
```

> **判定节点**
>
> 判定节点举例：
>
> - if语句
> - while语句
> - for语句
> - case语句
> - catch语句
> - and和or布尔操作
> - ?:三元运算符
>
> 多分支case结构或者if-else if-else结构，统计判定节点的个数要求为全部实际的判定节点数。
>
> 即每个else if以及每个case都算作一个判定节点。



##### 计算方式的选择

判定节点在模块的控制流图中很容易被识别出来，所以：

- 针对程序的控制流图计算圈复杂度V(G)时，一般采用点边计算法，也即V(G)=e-n+2；
- 针对模块的控制流图时，可以直接使用统计判定节点数，这样更为简单。



#### 圈复杂度和软件质量

| 圈复杂度 | 代码状况     | 可测性 | 维护成本 |
| :------- | :----------- | :----- | :------- |
| 1-10     | 清晰、结构化 | 高     | 低       |
| 10-20    | 复杂         | 中     | 中       |
| 20-30    | 非常复杂     | 低     | 高       |
| >30      | 不可读       | 不可测 | 非常高   |



#### 如何降低圈复杂度

##### 重新组织函数

- **提炼函数**

  有一段代码可以被组织在一起并独立出来，则将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。

  最后还要重新审视函数内容是否在统一层次上。

- **替换算法**

  把一个算法用更清晰的算法进行替换。

  ```java
  for (People people : peoples) {
      if (people == "Don"){
          return "Don";
      }
      if (people == "John"){
          return "John";
      }
      if (people == "Kent"){
          return "Kent";
      }
  }
  return "";
  ```

  ```java
  private static HashMap<String,String> peopleMap = new HashMap<>();
  static {
      peopleMap.put("Don","Don");
      peopleMap.put("John","John");
      peopleMap.put("Kent","Kent");
  }
  for (People people : peoples) {
      return Optional.ofNullable(peopleMap.get(people)).orElse("");
  }
  ```

##### 简化条件表达式

- **逆向表达**

  如原有的条件表达式很复杂，且他的取反条件比较简单，可以考虑改为反向判断。

  ```java
  //	如果条件1且条件2 或者非条件1
  if((condition1() && condition2()) || !condition1()){
      return 1;
  }
  return 0;
  ```

  ```java
  //	反过来就是 如果条件1且非条件2
  if(condition1() && !condition2()){
      return 0;
  }
  return 1;
  ```

- **分解条件**

  条件表达式以及各自的执行体比较大时，可以分别拆分为独立函数。

  ```java
  if(a < b || b < c || c < d){
      a+=b;b+=c;c+=d;
  }else{
      c+=d;b+=c;a+=b;
  }
  ```

  ```java
  // 三个表达式分别提取为单独的方法
  if(test(a,b,c)){
      method1(a,b,c);
  }else{
      method2(a,b,c);
  }
  ```

- **合并条件**

  如果一系列条件判断得到的结果相同，则将判断合并为一个条件，并将这个条件提炼为独立函数。

  ```java
  if (a < 2) return 0;
  if (b > 12) return 0;
  if (c) return 0;
  ```

  ```java
  public boolean test(a,b,c){
     return a < 2 || b > 12 || c; 
  }
  if(test(a,b,c))return 0;
  ```

- **移除控制印记**

  代码逻辑中有时会用布尔值作为逻辑控制标记，可以使用break和return取代这种标记。

  ```java
  boolean test = false;
  for(People people:peoples){
      if(!test){
          if(people == "a"){
              doSomeThing();
              test = true;
          }
      }
  }
  ```

  ```java
  for(People people:peoples){
      if(people == "a"){
          doSomeThing();
          break;
      }
  }
  ```

- **多态取代条件式**

  条件式根据对象类型选择不同行为的，将条件式的每个分支放入子类的重载方法，将原函数声明为抽象方法。

  ```java
  switch(a.getType()){
      case A:
          return doA();
      case B:
          return doB();
  }
  throw new RuntimeException ("Should be unreachable");
  ```

  ```java
  interface TotalClass{
      String getType();
      void do();
  }
  class ClassA implements TotalClass{
      String getType(){return "A"};
      void do(){doA();};
      private void doA();
  }
  class ClassB implements TotalClass{
      String getType(){return "B"};
      void do(){doB();};
      private void doB();
  }
  
  TotalClass caseClass = new ClassA();
  caseClass.do();
  ```



##### 简化函数调用

- **读写分离**

  某个函数既读取对象状态值，也能修改对象状态。将其拆分为两个函数，一个负责读取，一个负责查询。

- **参数化方法**

  若干函数执行类似工作，只是使用的值有区别。将其整合成一个函数，根据传值不同执行相同操作。

- **用明确函数取代参数**

  如函数实现根据参数值做出不同操作，可以将每个参数的操作拆分为一个独立方法。

  ```java
  void setValue(String column,Integer value){
      if(column == "A"){
          a = value;
      }
      if(column == "B"){
          b = value;
      }
  }
  ```

  ```java
  void setA(Integer value){
      a = value;
  }
  void setB(Integer value){
      b = value;
  }
  ```

  

#### 圈复杂度工具

- **IDEA圈复杂度插件MetricsReload**

  ![在这里插入图片描述](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/202207211333745.png)












# 数据库



## 数据库设计范式

数据库设计对数据的存储性能，还有开发人员对数据的操作都有莫大的关系。所以建立科学的，规范的的数据库是需要满足一些规范的来优化数据数据存储方式。

在关系型数据库中这些规范就可以称为范式。



**三大范式**

- **第一范式**：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。

- **第二范式**：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。

- **第三范式**：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF。



### 第一范式

- 每一列属性都是不可再分的属性值，确保每一列的原子性
- 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。



### 第二范式

- 每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。

  > 比如Order表（订单编号，房间号，联系人，电话）
  >
  > 一个人同时订几个房间，就会出现一个订单号多条数据（因为多个房间号）
  >
  > 这样的表结构，应该拆开来，如下。
  >
  > （订单编号，房间号，联系人编号）--（联系人编号，联系人，电话）



### 第三范式

- 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c  属性之间含有这样的关系，是不符合第三范式的。

  > 比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）
  >
  > 这样一个表结构，就存在上述关系。 学号--> 所在院校 --> (院校地址，院校电话)
  >
  > 这样的表结构，应该拆开来，如下。
  >
  > （学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）



### 补充

三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。

如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。

所以不能一味的去追求范式建立数据库。



## sql报错解决方案

#### （mysql）提示this is incompatible with sql_mode=only_full_group_by

**报错内容：**> 1055 - Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'df_hibaby.cm.name' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

![image-20210927150155397](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20210927150155397.png)

**原因分析：**当前数据库版本默认sql_mode为only_full_group_by，要求select的列必须出现在group by 条件内

```mysql
# 查询当前数据库sql_mode
select @@sql_mode
```

**解决方案：**

- 修改数据库sql_mode

  ```mysql
  # 对已经创建的数据库执行，但只对当前连接有效，重启后失效
  set @@sql_mode 
  ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
  ```

  ```ini
  # 修改配置文件my.ini或my.cnf 后重启
  [mysqld]
  sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'
  ```

- 或者 将查询列放在group by列中

**补充内容：sql_mode 配置解析**

- ONLY_FULL_GROUP_BY

  对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中。简而言之，就是SELECT后面接的列必须被GROUP BY后面接的列所包含。如：
  select a,b from table group by a,b,c; (正确)
  select a,b,c from table group by a,b; (错误)
  这个配置会使得GROUP BY语句环境变得十分狭窄，所以一般都不加这个配置

- NO_AUTO_VALUE_ON_ZERO

  该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。（不信的可以试试，默认的sql_mode你在自增主键列设置为0，该字段会自动变为最新的自增值，效果和null一样），如果用户希望插入的值为0（不改变），该列又是自增长的，那么这个选项就有用了。

- STRICT_TRANS_TABLES

  在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制。（InnoDB默认事务表，MyISAM默认非事务表；MySQL事务表支持将批处理当做一个完整的任务统一提交或回滚，即对包含在事务中的多条语句要么全执行，要么全部不执行。非事务表则不支持此种操作，批处理中的语句如果遇到错误，在错误前的语句执行成功，之后的则不执行；MySQL事务表有表锁与行锁非事务表则只有表锁）

- NO_ZERO_IN_DATE

  在严格模式下，不允许日期和月份为零

- NO_ZERO_DATE

  设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。

- ERROR_FOR_DIVISION_BY_ZERO

  在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL

- NO_AUTO_CREATE_USER

  禁止GRANT创建密码为空的用户

- NO_ENGINE_SUBSTITUTION

  如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常

- PIPES_AS_CONCAT

  将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似

- ANSI_QUOTES

  启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符







## 字符集

### 什么是字符集

字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 

**字符集** 就是一系列字符的集合。

每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。

> **计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？**
>
> 将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。
>
> 我们将字符对应二进制数据的过程称为"**字符编码**"，
>
> 反之，二进制数据解析成字符的过程称为“**字符解码**”。



### 常见字符集

ASCII、GB2312、GBK、UTF-8......

不同的字符集的主要区别在于：

- 可以表示的字符范围
- 编码方式



#### ASCII

**ASCII** (**A**merican **S**tandard **C**ode for **I**nformation **I**nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。



#### GB2312

GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。

对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。



#### GBK

GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。

GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。



#### GB18030

GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。



#### Unicode & UTF-8编码

Unicode 字符集中包含了世界上几乎所有已知的字符。

不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。

然后，就有了 **UTF-8**（**8**-bit **U**nicode **T**ransformation **F**ormat）。类似的还有 UTF-16、 UTF-32。

UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。

UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。

UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。

**UTF-8** 是目前使用最广的一种字符编码。



### MySql字符集

MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。

通过 `SHOW CHARSET` 命令来查看。

<img src="https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20220513230423018.png" alt="image-20220513230423018" style="zoom:50%;" />

通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。



#### utf8 与 utf8mb4

MySQL 字符编码集中有两套 UTF-8 编码实现：

- **`utf8`** ： `utf8`编码只支持`1-3`个字节 。 在 `utf8` 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。
- **`utf8mb4`** ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。

> **为什么有两套 UTF-8 编码实现呢？** 原因如下：
>
> ![img](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/image-20211008164542347.png)

因此，如果你需要存储`emoji`类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为`utf8mb4` 而不是`utf8` ，要不然存储的时候就会报错了。



## 关系型数据库

关系型数据库就是一种建立在关系模型的基础上的数据库。

关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。

关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。

大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。

### 常见的关系型数据库

- MySQL
- PostgreSQL
- Oracle
- SQL Server
- SQLite（微信本地的聊天记录的存储就是用的 SQLite） 
- ......





## 事务

### 什么是事务

事务是逻辑上的一组操作，要么都执行，要么都不执行。



### 什么是数据库事务

数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个**逻辑上的整体**。

构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功,要么全部不执行** 。

```mysql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```



### 事务特性：ACID

关系型数据库（例如：`MySQL`、`SQL Server`、`Oracle` 等）事务都有 **ACID** 特性：

![事务的特性](https://strangest.oss-cn-shanghai.aliyuncs.com/markdown/dfsfsfsfinnodb.png)

1. **原子性（Atomicity）**

   事务是最小的执行单位，不允许分割。

   事务的原子性确保动作要么全部完成，要么完全不起作用；

2. **一致性（Consistency）**

   执行事务前后，数据保持一致。

   如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

3. **隔离性（Isolation）**

   并发访问数据库时，一个用户的事务不被其他事务所干扰。

   各并发事务之间数据库是独立的；

4. **持久性（Durability）**

   一个事务被提交之后，它对数据库中数据的改变是持久的。

   即使数据库发生故障也不应该对其有任何影响。



### 事务隔离级别有哪几种

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)**

  最低的隔离级别，允许读取尚未提交的数据变更。

  会导致 脏读，幻读，不可重复读。

- **READ-COMMITTED(读取已提交)**

  允许读取并发事务已经提交的数据。

  可以阻止脏读，

  不能阻止幻读，不可重复读。

- **REPEATABLE-READ(可重复读)**

  同一事务内对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改。

  可以阻止脏读和不可重复读，

  不能阻止幻读。

- **SERIALIZABLE(可串行化)**

  最高隔离级别，

  所有事务依次逐个执行，事务之间完全不可能互相干扰。

  可以阻止脏读，幻读，不可重复读。



### 脏读/幻读/不可重复读/丢失修改...

- **脏读（Dirty read）**

  当一个事务正在访问数据并且对数据进行了修改，而这种修改**还没有提交到数据库**中，

  同时另外一个事务也访问了这个数据，然后使用了这个数据。

  因为这个数据是**还没有提交的数据**，那么另外一个事务读到的这个数据是“脏数据”，

  依据“脏数据”所做的操作可能是不正确的。

- **丢失修改（Lost to modify）**

  在一个事务读取一个数据时，同时另外一个事务也访问了该数据，

  并且在**第一个事务中修改了这个数据后，第二个事务也修改了这个数据**。

  这样第一个事务内的修改结果就会丢失，因此称为丢失修改。

- **不可重复读（Unrepeatable read）**

  在一个事务内多次读同一数据，

  在这个事务还没有结束时，另一个事务也访问该数据，并修改数据，

  在第一个事务中的**两次读数据之间**，由于第二个事务的修改导致第一个事务**两次读取的数据可能不太一样**。

  在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

- **幻读（Unrepeatable read）**

  与不可重复读类似，

  在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时，

  在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，

  就好像发生了幻觉一样，所以称为幻读。

### 不可重复读与幻读的区别

- 不可重复读的重点是修改。

  如多次读取一条记录发现其中某些列的值被修改。

- 幻读的重点是新增或者删除。

  如多次查询同一条查询语句（DQL）时，记录发现记录增多或减少了。





